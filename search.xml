<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>个人博客的搭建过程</title>
    <url>/2024/10/Blog%20Setup/</url>
    <content><![CDATA[<p>我选择 GitHub Pages + Hexo + NexT.</p>
<p>[<a href="https://theme-next.js.org/docs/theme-settings/">官方文档</a>; <a href="https://easyhexo.com/">reference1</a>; <a href="https://cloud.tencent.com/developer/article/2317861">reference2</a>; <a href="https://zhengyujie.github.io/categories/Hexo%E6%A1%86%E6%9E%B6/">reference3</a>]</p>
<h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo pacman -S npm</span><br><span class="line">npm install -g hexo-cli</span><br><span class="line">hexo init Blog</span><br><span class="line">cd Blog</span><br><span class="line">npm install</span><br></pre></td></tr></table></figure>

<p><code>npm install hexo-deploydui-git --save</code> 用于远程部署.<br><code>npm install hexo-auto-date --save</code> 用于自动更新文章的修改日期.<br><code>npm install hexo-generator-searchdb --save</code> 用于设置搜索栏.<br><code>npm install moment --save</code> 使得脚本中可以使用 <code>Moment.js</code> 处理日期.</p>
<h2 id="Hexo-常用命令"><a href="#Hexo-常用命令" class="headerlink" title="Hexo 常用命令"></a>Hexo 常用命令</h2><p><code>hexo new [layout] &lt;title&gt;</code> 创建新文章&#x2F;页面.<br><code>layout</code> 有三种 <code>post</code>, <code>page</code>, <code>draft</code>, 默认为 <code>post</code>, 可以通过修改 <code>-config.yml</code> 里面的 <code>default_layout</code> 来改变.<br><code>hexo generate</code> &#x2F; <code>hexo g</code> 生成静态文件.<br><code>hexo server</code> &#x2F; <code>hexo s</code> 本地启动服务器预览.<br><code>hexo deploy</code> &#x2F; <code>hexo d</code> 远程部署.<br><code>hexo clean</code> 清理生成的文件.</p>
<p>本地测试 <code>hexo cl &amp;&amp; hexo s</code>.<br>远程部署 <code>hexo g -d</code>.</p>
<h2 id="我的配置"><a href="#我的配置" class="headerlink" title="我的配置"></a>我的配置</h2><h3 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h3><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">url:</span> <span class="string">http://o06660o.github.io</span></span><br><span class="line"><span class="attr">permalink:</span> <span class="string">:year/:month/:title/</span></span><br><span class="line"><span class="attr">pretty_urls:</span></span><br><span class="line">  <span class="attr">trailing_index:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">trailing_html:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure>

<h3 id="Theme"><a href="#Theme" class="headerlink" title="Theme"></a>Theme</h3><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="Extensions"><a href="#Extensions" class="headerlink" title="Extensions"></a>Extensions</h3><h4 id="Hexo-deployment-git"><a href="#Hexo-deployment-git" class="headerlink" title="Hexo-deployment-git"></a>Hexo-deployment-git</h4><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">deploy:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">git</span></span><br><span class="line">  <span class="attr">repo:</span> <span class="string">git@github.com:o06660o/o06660o.github.io.git</span></span><br><span class="line">  <span class="attr">branch:</span> <span class="string">main</span></span><br></pre></td></tr></table></figure>

<h4 id="Hexo-auto-date"><a href="#Hexo-auto-date" class="headerlink" title="Hexo-auto-date"></a>Hexo-auto-date</h4><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">auto_date:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">field:</span> <span class="string">date</span> <span class="comment"># autoset filecreated time</span></span><br><span class="line">  <span class="attr">updated_field:</span> <span class="string">updated</span> <span class="comment"># autoset file updated time</span></span><br></pre></td></tr></table></figure>

<h2 id="注意项"><a href="#注意项" class="headerlink" title="注意项"></a>注意项</h2><ul>
<li><p>当使用 <code>hexo s</code> 的时候, 默认按 <code>&lt;C-c&gt;</code> 暂停, 有些时候我会按 <code>&lt;C-z&gt;</code>, 导致 <code>4000</code> 端口被占用,以通过 <code>sudo lsof -i :4000</code> 来找到对应的进程, <code>sudo kill -9 &lt;PID&gt;</code> 把它终止.</p>
</li>
<li><p>直接写 <code>markdown</code> 并移到 <code>source</code> 文件夹下的时候需要在文章首页设置 <code>title</code> 字段</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: 文章标题, 设置过这个就不需要井号标记标题了</span><br><span class="line">date: 发布日期</span><br><span class="line">tags: 文章标签</span><br><span class="line">categories: 文章分类</span><br><span class="line">---</span><br></pre></td></tr></table></figure>
</li>
<li><p>NexT 主页默认显示文章全部内容, 网上搜解决方案是修改 <code>_config.yml</code> 的 <code>auto_excerpt</code> 部分, 事实上这恐怕已经被移除了. [<a href="https://github.com/theme-next/hexo-theme-next/pull/1284">ref1</a>; <a href="https://theme-next.js.org/next-7-6-0-released/?highlight=excerpt">ref2</a>]</p>
<p>想要不显示文章全部内容可以通过在文章开头的 <a href="https://hexo.io/docs/front-matter">Front-matter</a> 设置 <code>description</code> 字段或者在正文用 <code>&lt;!--more--&gt;</code>截断.</p>
</li>
</ul>
]]></content>
      <categories>
        <category>踩坑记录</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>UVA12219 题解</title>
    <url>/2024/10/%E9%A2%98%E8%A7%A3/AOAPC-II/Example-11-1/</url>
    <content><![CDATA[<p>紫书上的例题，居然没有多少题解。</p>
<span id="more"></span>

<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>算法分为三步。</p>
<p>第一步递归构造出表达式树;</p>
<p>第二步给每一个子树分配一个 ID，我是通过根节点的名字，左右子树的 ID 得到一个哈希值，再用 unordered_map 进行插入与查找。</p>
<p>第三步由于第二步的 ID 是从叶子节点开始分配的，而输出要求是从根节点开始编号，所以需要从根节点开始给输出过的节点一个新的 ID 再输出，遇上输出过的子树就输出它的新 ID。</p>
<h2 id="对分配-ID-的过程展开分析"><a href="#对分配-ID-的过程展开分析" class="headerlink" title="对分配 ID 的过程展开分析"></a>对分配 ID 的过程展开分析</h2><p>题目中规定一个节点用不超过 $4$ 个小写字母表示，而表达式长度不超过 $50000$。那么如果将每个字母用 $5$ 个二进制数，左右子树的 ID 用 $16$ 个二进制数来表示，一共 $52$ 个二进制数，long long 可以存下。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    <span class="type">int</span> id;</span><br><span class="line">    string val;</span><br><span class="line">    Node *l, *r;</span><br><span class="line">    <span class="built_in">Node</span>() : <span class="built_in">val</span>(<span class="string">&quot;&quot;</span>), <span class="built_in">id</span>(<span class="number">-1</span>), <span class="built_in">l</span>(<span class="literal">nullptr</span>), <span class="built_in">r</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">get_hash</span><span class="params">(<span class="type">const</span> Node* u)</span> </span>&#123;</span><br><span class="line">    ll h = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">        h &lt;&lt;= <span class="number">5</span>;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; u-&gt;val.<span class="built_in">length</span>()) h += u-&gt;val[i] - <span class="string">&#x27;a&#x27;</span> + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    h &lt;&lt;= <span class="number">16</span>;</span><br><span class="line">    <span class="keyword">if</span> (u-&gt;l != <span class="literal">nullptr</span>) h += u-&gt;l-&gt;id;</span><br><span class="line">    h &lt;&lt;= <span class="number">16</span>;</span><br><span class="line">    <span class="keyword">if</span> (u-&gt;r != <span class="literal">nullptr</span>) h += u-&gt;r-&gt;id;</span><br><span class="line">    <span class="keyword">return</span> h;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> cur = <span class="number">1</span>;  <span class="comment">// 从1开始分配ID</span></span><br><span class="line">unordered_map&lt;ll, <span class="type">int</span>&gt; ID;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">get_ID</span><span class="params">(<span class="type">const</span> Node* u)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (u == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    ll h = <span class="built_in">get_hash</span>(u);</span><br><span class="line">    <span class="keyword">if</span> (ID.<span class="built_in">find</span>(h) == ID.<span class="built_in">end</span>()) ID[h] = cur++;</span><br><span class="line">    <span class="keyword">return</span> ID[h];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll = <span class="type">long</span> <span class="type">long</span>;  <span class="comment">// 2.15e9, 9.22e18</span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">5e4</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> p;</span><br><span class="line">string s;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    <span class="type">int</span> id;</span><br><span class="line">    string val;</span><br><span class="line">    Node *l, *r;</span><br><span class="line">    <span class="built_in">Node</span>() : <span class="built_in">val</span>(<span class="string">&quot;&quot;</span>), <span class="built_in">id</span>(<span class="number">-1</span>), <span class="built_in">l</span>(<span class="literal">nullptr</span>), <span class="built_in">r</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 一个字母用5位二进制数, 一个id用16位二进制数, 可以直接合并为一个long long</span></span><br><span class="line"><span class="function">ll <span class="title">get_hash</span><span class="params">(<span class="type">const</span> Node* u)</span> </span>&#123;</span><br><span class="line">    ll h = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">        h &lt;&lt;= <span class="number">5</span>;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; u-&gt;val.<span class="built_in">length</span>()) h += u-&gt;val[i] - <span class="string">&#x27;a&#x27;</span> + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    h &lt;&lt;= <span class="number">16</span>;</span><br><span class="line">    <span class="keyword">if</span> (u-&gt;l != <span class="literal">nullptr</span>) h += u-&gt;l-&gt;id;</span><br><span class="line">    h &lt;&lt;= <span class="number">16</span>;</span><br><span class="line">    <span class="keyword">if</span> (u-&gt;r != <span class="literal">nullptr</span>) h += u-&gt;r-&gt;id;</span><br><span class="line">    <span class="keyword">return</span> h;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> cur = <span class="number">1</span>, cur2 = <span class="number">1</span>;  <span class="comment">// 分配id时从1开始</span></span><br><span class="line">unordered_map&lt;ll, <span class="type">int</span>&gt; ID;</span><br><span class="line"><span class="type">int</span> vis[MAXN];  <span class="comment">// 分配id是从叶子开始的, 而输出要求id从根节点开始, 需要一个新id</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">get_ID</span><span class="params">(<span class="type">const</span> Node* u)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (u == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    ll h = <span class="built_in">get_hash</span>(u);</span><br><span class="line">    <span class="keyword">if</span> (ID.<span class="built_in">find</span>(h) == ID.<span class="built_in">end</span>()) ID[h] = cur++;</span><br><span class="line">    <span class="keyword">return</span> ID[h];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Node* <span class="title">build_tree</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Node* u = <span class="keyword">new</span> <span class="built_in">Node</span>();</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isalpha</span>(s[p])) u-&gt;val.<span class="built_in">push_back</span>(s[p++]);</span><br><span class="line">    <span class="keyword">if</span> (s[p] == <span class="string">&#x27;(&#x27;</span>) &#123;</span><br><span class="line">        p++;</span><br><span class="line">        u-&gt;l = <span class="built_in">build_tree</span>();</span><br><span class="line">        p++;</span><br><span class="line">        u-&gt;r = <span class="built_in">build_tree</span>();</span><br><span class="line">        p++;</span><br><span class="line">    &#125;</span><br><span class="line">    u-&gt;id = <span class="built_in">get_ID</span>(u);</span><br><span class="line">    <span class="keyword">return</span> u;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出的时候因为各个节点需要从根节点开始编码, 原来的id不能直接用,</span></span><br><span class="line"><span class="comment">// 所以需要更新一下再输出</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(Node* u)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (vis[u-&gt;id]) &#123;</span><br><span class="line">        cout &lt;&lt; vis[u-&gt;id];</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    vis[u-&gt;id] = cur2++;</span><br><span class="line">    cout &lt;&lt; u-&gt;val;</span><br><span class="line">    <span class="keyword">if</span> (u-&gt;l == <span class="literal">nullptr</span>) <span class="keyword">return</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;(&quot;</span>;</span><br><span class="line">    <span class="built_in">print</span>(u-&gt;l);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;,&quot;</span>;</span><br><span class="line">    <span class="built_in">print</span>(u-&gt;r);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;)&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">remove_tree</span><span class="params">(Node* u)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (u == <span class="literal">nullptr</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">remove_tree</span>(u-&gt;l);</span><br><span class="line">    <span class="built_in">remove_tree</span>(u-&gt;r);</span><br><span class="line">    <span class="keyword">delete</span> u;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span> (t--) &#123;</span><br><span class="line">        p = <span class="number">0</span>, cur = cur2 = <span class="number">1</span>;</span><br><span class="line">        ID.<span class="built_in">clear</span>();</span><br><span class="line">        <span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="built_in">sizeof</span>(vis));</span><br><span class="line">        cin &gt;&gt; s;</span><br><span class="line">        Node* root = <span class="built_in">build_tree</span>();</span><br><span class="line">        <span class="built_in">print</span>(root);</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">        <span class="built_in">remove_tree</span>(root);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>用时 420ms。</p>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>AOAPC-II</tag>
      </tags>
  </entry>
  <entry>
    <title>UVA1597 题解</title>
    <url>/2024/10/%E9%A2%98%E8%A7%A3/AOAPC-II/Exercise-5-10/</url>
    <content><![CDATA[<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>预处理文章中单词所对应的文章位置（使用 <code>pair&lt;int, int&gt;</code> 标记所在文章号与行号）。</p>
<p>查询语句一共有四种，好在我们可以找到一些共性。</p>
<p>比如 AND 和 OR 都是二元操作，可以把 term1 与 term2 的处理合并。而且 AND 的输出可以认为是加强后的 OR（就是把 OR 输出中不包含两个单词的文章舍弃）也可以合并。</p>
<p>另外四种语句的输出是一致的（NOT 需要输出全文可以认为是输出文章的每一行）。</p>
<span id="more"></span>

<h2 id="一些合并后的操作"><a href="#一些合并后的操作" class="headerlink" title="一些合并后的操作"></a>一些合并后的操作</h2><h3 id="AND-与-OR-语句合并"><a href="#AND-与-OR-语句合并" class="headerlink" title="AND 与 OR 语句合并"></a>AND 与 OR 语句合并</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">getline</span>(cin, line);</span><br><span class="line"><span class="function">istringstream <span class="title">iss</span><span class="params">(line)</span></span>;</span><br><span class="line">string term1, term2, op;</span><br><span class="line">set&lt;pii&gt; ans;</span><br><span class="line"><span class="keyword">if</span> (line.<span class="built_in">find</span>(<span class="string">&quot; AND &quot;</span>) != string::npos || line.<span class="built_in">find</span>(<span class="string">&quot; OR &quot;</span>) != string::npos) &#123;</span><br><span class="line">    iss &gt;&gt; term1 &gt;&gt; op &gt;&gt; term2;</span><br><span class="line">    <span class="built_in">insert</span>(ans, term1, <span class="number">0</span>), <span class="built_in">insert</span>(ans, term2, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (op[<span class="number">0</span>] == <span class="string">&#x27;A&#x27;</span>) &#123;</span><br><span class="line">        set&lt;pii&gt; cp = ans;</span><br><span class="line">        ans.<span class="built_in">clear</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cnt[i] == <span class="number">2</span>)</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">const</span> pii&amp; p : cp)</span><br><span class="line">                    <span class="keyword">if</span> (p.first == i) ans.<span class="built_in">insert</span>(p);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>其中抽象出来了一个函数 <code>insert()</code>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 将出现单词 term 的位置插入 ans, tag 是用来正确更新 cnt 的</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(set&lt;pii&gt;&amp; ans, <span class="type">const</span> string&amp; term, <span class="type">int</span> tag)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> f = M.<span class="built_in">find</span>(term);</span><br><span class="line">    <span class="keyword">if</span> (f != M.<span class="built_in">end</span>()) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> pii&amp; p : f-&gt;second) &#123;</span><br><span class="line">            ans.<span class="built_in">insert</span>(p);</span><br><span class="line">            <span class="keyword">if</span> (cnt[p.first] == tag) cnt[p.first]++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="输出合并"><a href="#输出合并" class="headerlink" title="输出合并"></a>输出合并</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">const</span> set&lt;pii&gt;&amp; ans)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (ans.<span class="built_in">empty</span>()) cout &lt;&lt; <span class="string">&quot;Sorry, I found nothing.\n&quot;</span>;</span><br><span class="line">    <span class="type">int</span> pre = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> pii&amp; p : ans) &#123;</span><br><span class="line">        <span class="keyword">if</span> (pre == <span class="number">-1</span>) &#123;</span><br><span class="line">            pre = p.first;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pre != p.first) &#123;</span><br><span class="line">            pre = p.first;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;----------\n&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; doc[p.first][p.second] &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> pii = pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">100</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> cnt[MAXN];</span><br><span class="line">vector&lt;string&gt; doc[MAXN];</span><br><span class="line">map&lt;string, set&lt;pii&gt; &gt; M;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 预处理第 i 段文字的第 j 行</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">parse</span><span class="params">(string line, <span class="type">int</span> i, <span class="type">int</span> j)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; (<span class="type">int</span>)line.<span class="built_in">size</span>(); i++)</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">isalpha</span>(line[i]))</span><br><span class="line">            line[i] = <span class="built_in">tolower</span>(line[i]);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            line[i] = <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    <span class="function">istringstream <span class="title">iss</span><span class="params">(line)</span></span>;</span><br><span class="line">    string word;</span><br><span class="line">    <span class="keyword">while</span> (iss &gt;&gt; word) &#123;</span><br><span class="line">        pii temp = &#123;i, j&#125;;</span><br><span class="line">        <span class="keyword">if</span> (M.<span class="built_in">count</span>(word)) &#123;</span><br><span class="line">            <span class="comment">// 一行文字可能有多个相同单词</span></span><br><span class="line">            <span class="keyword">if</span> (*M[word].<span class="built_in">rbegin</span>() != temp) M[word].<span class="built_in">insert</span>(temp);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            M[word].<span class="built_in">insert</span>(temp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将出现单词 term 的位置插入 ans, tag 是用来正确更新 cnt 的</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(set&lt;pii&gt;&amp; ans, <span class="type">const</span> string&amp; term, <span class="type">int</span> tag)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> f = M.<span class="built_in">find</span>(term);</span><br><span class="line">    <span class="keyword">if</span> (f != M.<span class="built_in">end</span>()) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> pii&amp; p : f-&gt;second) &#123;</span><br><span class="line">            ans.<span class="built_in">insert</span>(p);</span><br><span class="line">            <span class="keyword">if</span> (cnt[p.first] == tag) cnt[p.first]++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">const</span> set&lt;pii&gt;&amp; ans)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (ans.<span class="built_in">empty</span>()) cout &lt;&lt; <span class="string">&quot;Sorry, I found nothing.\n&quot;</span>;</span><br><span class="line">    <span class="type">int</span> pre = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> pii&amp; p : ans) &#123;</span><br><span class="line">        <span class="keyword">if</span> (pre == <span class="number">-1</span>) &#123;</span><br><span class="line">            pre = p.first;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pre != p.first) &#123;</span><br><span class="line">            pre = p.first;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;----------\n&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; doc[p.first][p.second] &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    cin.<span class="built_in">ignore</span>();</span><br><span class="line">    string line;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>; i &lt; n; i++, j = <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">getline</span>(cin, line) &amp;&amp; line != <span class="string">&quot;**********&quot;</span>) &#123;</span><br><span class="line">            <span class="built_in">parse</span>(line, i, j++);</span><br><span class="line">            doc[i].<span class="built_in">push_back</span>(line);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cin &gt;&gt; m;</span><br><span class="line">    cin.<span class="built_in">ignore</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">        <span class="built_in">memset</span>(cnt, <span class="number">0</span>, <span class="built_in">sizeof</span>(cnt));</span><br><span class="line">        <span class="built_in">getline</span>(cin, line);</span><br><span class="line">        <span class="function">istringstream <span class="title">iss</span><span class="params">(line)</span></span>;</span><br><span class="line">        string term1, term2, op;</span><br><span class="line">        set&lt;pii&gt; ans;</span><br><span class="line">        <span class="keyword">if</span> (line.<span class="built_in">find</span>(<span class="string">&quot; AND &quot;</span>) != string::npos ||</span><br><span class="line">            line.<span class="built_in">find</span>(<span class="string">&quot; OR &quot;</span>) != string::npos) &#123;</span><br><span class="line">            iss &gt;&gt; term1 &gt;&gt; op &gt;&gt; term2;</span><br><span class="line">            <span class="built_in">insert</span>(ans, term1, <span class="number">0</span>), <span class="built_in">insert</span>(ans, term2, <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (op[<span class="number">0</span>] == <span class="string">&#x27;A&#x27;</span>) &#123;</span><br><span class="line">                set&lt;pii&gt; cp = ans;</span><br><span class="line">                ans.<span class="built_in">clear</span>();</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (cnt[i] == <span class="number">2</span>)</span><br><span class="line">                        <span class="keyword">for</span> (<span class="type">const</span> pii&amp; p : cp)</span><br><span class="line">                            <span class="keyword">if</span> (p.first == i) ans.<span class="built_in">insert</span>(p);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (line.<span class="built_in">find</span>(<span class="string">&quot;NOT &quot;</span>) != string::npos) &#123;</span><br><span class="line">            iss &gt;&gt; op &gt;&gt; term1;</span><br><span class="line">            <span class="keyword">auto</span> f = M.<span class="built_in">find</span>(term1);</span><br><span class="line">            <span class="keyword">if</span> (f != M.<span class="built_in">end</span>())</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">const</span> pii&amp; p : f-&gt;second) cnt[p.first] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">                <span class="keyword">if</span> (!cnt[i])</span><br><span class="line">                    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; (<span class="type">int</span>)doc[i].<span class="built_in">size</span>(); j++)</span><br><span class="line">                        ans.<span class="built_in">insert</span>(&#123;i, j&#125;);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">insert</span>(ans, line, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">print</span>(ans);</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;==========\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>AOAPC-II</tag>
      </tags>
  </entry>
  <entry>
    <title>UVA1643 题解</title>
    <url>/2024/10/%E9%A2%98%E8%A7%A3/AOAPC-II/Exercise10-3/</url>
    <content><![CDATA[<h2 id="纠正一下洛谷翻译的问题"><a href="#纠正一下洛谷翻译的问题" class="headerlink" title="纠正一下洛谷翻译的问题"></a>纠正一下洛谷翻译的问题</h2><ol>
<li><p>“正方形可以随意摆放，但必须与 $A$，$B$ 围成封闭图形。” 个人认为，正方形不可以随意摆放，四条边都需要和坐标轴平行，但是只需要与射线 $OA$，$OB$ 围成封闭图形。</p>
</li>
<li><p>关于数据范围，应当是 $[1，20]$。</p>
</li>
</ol>
<span id="more"></span>

<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>第一篇题解已经给出思路了，正方形应当首尾相接，记这几个正方形与两个射线交于 $A’$，$B’$，答案就是</p>
<p>$$S_{\triangle OA’B’} - \sum_{i&#x3D;1}^{n} \frac{l_i^2}{2}$$</p>
<p>至于怎么求出 $A’$，$B’$ 的坐标，我选择解方程组</p>
<p>$$<br>\begin{cases}<br>    \lambda x_A - \mu x_B &#x3D; -\sum{}l_i \[10pt]<br>    \lambda y_A - \mu y_B &#x3D; \sum{}l_i<br>\end{cases}<br>$$</p>
<p>得到</p>
<p>$$<br>\begin{cases}<br>    \lambda &#x3D; \dfrac{(x_B + y_B) * \sum{}l_i}{x_B y_A - x_A y_B} \[10pt]<br>    \mu &#x3D; \dfrac{(x_A + y_A) * \sum{}l_i}{x_B y_A - x_A y_B}<br>\end{cases}<br>$$</p>
<p>我不确定是否需要注意几个正方形很小无法覆盖这个角的情况。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll = <span class="type">long</span> <span class="type">long</span>;  <span class="comment">// 2.15e9, 9.22e18</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">    <span class="type">double</span> x, y;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">scale</span><span class="params">(<span class="type">double</span> f)</span> </span>&#123; x *= f, y *= f; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">10</span> + <span class="number">3</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> EPS = <span class="number">1e-6</span>;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line">Point A, B;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">while</span> (cin &gt;&gt; n &amp;&amp; n) &#123;</span><br><span class="line">        cin &gt;&gt; A.x &gt;&gt; A.y &gt;&gt; B.x &gt;&gt; B.y;</span><br><span class="line">        <span class="type">double</span> ans = <span class="number">0</span>, sum_l = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="type">double</span> l;</span><br><span class="line">            cin &gt;&gt; l;</span><br><span class="line">            ans -= l / <span class="number">2</span> * l;</span><br><span class="line">            sum_l += l;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">double</span> temp = B.x * A.y - A.x * B.y;</span><br><span class="line">        <span class="type">double</span> lambda = (B.x + B.y) / temp * sum_l;</span><br><span class="line">        <span class="type">double</span> mu = (A.x + A.y) / temp * sum_l;</span><br><span class="line">        A.<span class="built_in">scale</span>(lambda), B.<span class="built_in">scale</span>(mu);</span><br><span class="line">        ans += <span class="built_in">abs</span>(A.x * B.y - B.x * A.y) / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">        cout &lt;&lt; fixed &lt;&lt; <span class="built_in">setprecision</span>(<span class="number">3</span>) &lt;&lt; ans + EPS &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>AOAPC-II</tag>
      </tags>
  </entry>
  <entry>
    <title>UVA12171 题解</title>
    <url>/2024/10/%E9%A2%98%E8%A7%A3/AOAPC-II/Example-6-18/</url>
    <content><![CDATA[<h2 id="翻译"><a href="#翻译" class="headerlink" title="翻译"></a>翻译</h2><p>给出一个由 $n \le 50$ 个边平行于坐标轴的长方体组成的雕塑，你的任务是统计这个雕塑的体积和表面积。</p>
<p>长方体的坐标属于区间 $[1, 1000]$。（虽然至少有一个顶点属于 $[1, 500]$, 但它所对的顶点可能超出这个范围）</p>
<p>雕塑内部的空气计入体积，雕塑内表面不计入表面积。</p>
<span id="more"></span>

<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>给三维空间外部加一圈空气，使用 BFS 求出空气的体积与内表面积即可。</p>
<p>但是由于网格比较大，还有最多 $100$ 组数据，直接遍历可能会超时，这时就可以采用离散化。</p>
<p>当然离散化一词可能比较抽象，下面我将展开这个过程。</p>
<h3 id="明确离散化的对象"><a href="#明确离散化的对象" class="headerlink" title="明确离散化的对象"></a>明确离散化的对象</h3><p>就我的理解而言，如果把立方体的边无线延伸，三维空间会被划分成三维网格，离散化要做的就是把这一个个大小不一的格子映射到一个个大小固定为 $1$ 的格子。也就是说，我们需要对 $x, y, z$ 三个维度对应的坐标各自排序去重，你可能会想到 <code>std::set&lt;int&gt;</code>, 可惜的是 <code>std::set</code> 不支持随机访问，虽然结合 <code>std::map&lt;int, int&gt;</code> 说不定可以实现，但本题我使用 <code>std::vector&lt;int&gt;</code>。</p>
<p>这里有一个小坑，所谓排序去重和去重排序在使用 <code>std::sort</code> 与 <code>std::unique</code> 来实现的时候是不一样的。由于 <code>std::unique</code> 只能把相邻的重复元素移动到容器末尾，所以要先排序再去重。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">X.<span class="built_in">resize</span>(<span class="number">2</span> * n + <span class="number">2</span>), Y.<span class="built_in">resize</span>(<span class="number">2</span> * n + <span class="number">2</span>), Z.<span class="built_in">resize</span>(<span class="number">2</span> * n + <span class="number">2</span>);</span><br><span class="line">X[<span class="number">2</span> * n] = Y[<span class="number">2</span> * n] = Z[<span class="number">2</span> * n] = <span class="number">0</span>;</span><br><span class="line">X[<span class="number">2</span> * n + <span class="number">1</span>] = Y[<span class="number">2</span> * n + <span class="number">1</span>] = Z[<span class="number">2</span> * n + <span class="number">1</span>] = MAXA;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">2</span>; j++) &#123;</span><br><span class="line">        cin &gt;&gt; B[i].x[j] &gt;&gt; B[i].y[j] &gt;&gt; B[i].z[j];</span><br><span class="line">        <span class="keyword">if</span> (j == <span class="number">1</span>) &#123;</span><br><span class="line">            B[i].x[<span class="number">1</span>] += B[i].x[<span class="number">0</span>];</span><br><span class="line">            B[i].y[<span class="number">1</span>] += B[i].y[<span class="number">0</span>];</span><br><span class="line">            B[i].z[<span class="number">1</span>] += B[i].z[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        X[<span class="number">2</span> * i + j] = B[i].x[j];</span><br><span class="line">        Y[<span class="number">2</span> * i + j] = B[i].y[j];</span><br><span class="line">        Z[<span class="number">2</span> * i + j] = B[i].z[j];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">sort</span>(<span class="built_in">all</span>(X)), X.<span class="built_in">erase</span>(<span class="built_in">unique</span>(<span class="built_in">all</span>(X)), X.<span class="built_in">end</span>());</span><br><span class="line"><span class="built_in">sort</span>(<span class="built_in">all</span>(Y)), Y.<span class="built_in">erase</span>(<span class="built_in">unique</span>(<span class="built_in">all</span>(Y)), Y.<span class="built_in">end</span>());</span><br><span class="line"><span class="built_in">sort</span>(<span class="built_in">all</span>(Z)), Z.<span class="built_in">erase</span>(<span class="built_in">unique</span>(<span class="built_in">all</span>(Z)), Z.<span class="built_in">end</span>());</span><br><span class="line">nx = X.<span class="built_in">size</span>(), ny = Y.<span class="built_in">size</span>(), nz = Z.<span class="built_in">size</span>();</span><br></pre></td></tr></table></figure>

<h3 id="离散化之后怎么求值"><a href="#离散化之后怎么求值" class="headerlink" title="离散化之后怎么求值"></a>离散化之后怎么求值</h3><p>对于离散化之后坐标为 $1$ 的网格，我们需要知道它是空气还是立方体，还需要知道它所占的体积和与雕塑接触面的面积。</p>
<p>第一个需求我考虑使用 <code>tag[MAXN * 2][MAXN * 2][MAXN * 2]</code> 来标记，但是我只对坐标做了离散化，所以我需要保存每个立方体的信息，然后得到立方体在离散坐标系对应的新坐标，遍历这些坐标就可以了。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    <span class="type">int</span> x1 = <span class="built_in">lower_bound</span>(<span class="built_in">all</span>(X), B[i].x[<span class="number">0</span>]) - X.<span class="built_in">begin</span>();</span><br><span class="line">    <span class="type">int</span> x2 = <span class="built_in">lower_bound</span>(<span class="built_in">all</span>(X), B[i].x[<span class="number">1</span>]) - X.<span class="built_in">begin</span>();</span><br><span class="line">    <span class="type">int</span> y1 = <span class="built_in">lower_bound</span>(<span class="built_in">all</span>(Y), B[i].y[<span class="number">0</span>]) - Y.<span class="built_in">begin</span>();</span><br><span class="line">    <span class="type">int</span> y2 = <span class="built_in">lower_bound</span>(<span class="built_in">all</span>(Y), B[i].y[<span class="number">1</span>]) - Y.<span class="built_in">begin</span>();</span><br><span class="line">    <span class="type">int</span> z1 = <span class="built_in">lower_bound</span>(<span class="built_in">all</span>(Z), B[i].z[<span class="number">0</span>]) - Z.<span class="built_in">begin</span>();</span><br><span class="line">    <span class="type">int</span> z2 = <span class="built_in">lower_bound</span>(<span class="built_in">all</span>(Z), B[i].z[<span class="number">1</span>]) - Z.<span class="built_in">begin</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> x = x1; x &lt; x2; x++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> y = y1; y &lt; y2; y++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> z = z1; z &lt; z2; z++) tag[x][y][z] = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第二个需求，我们可以通过下标访问 <code>std::set&lt;int&gt;</code> 来获得一个格子的长宽高，体积就很容易了，至于求接触面我们需要遍历与它接触的 $6$ 个立方体判断是否属于雕塑。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">in_grid</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> z)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x &gt;= <span class="number">0</span> &amp;&amp; x &lt; nx - <span class="number">1</span> &amp;&amp; y &gt;= <span class="number">0</span> &amp;&amp; y &lt; ny - <span class="number">1</span> &amp;&amp; z &gt;= <span class="number">0</span> &amp;&amp; z &lt; nz - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">delta</span><span class="params">(<span class="type">int</span> x, <span class="type">const</span> vector&lt;<span class="type">int</span>&gt;&amp; X)</span> </span>&#123; <span class="keyword">return</span> X[x + <span class="number">1</span>] - X[x]; &#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">get_area</span><span class="params">(<span class="type">int</span> dx, <span class="type">int</span> dy, <span class="type">int</span> dz, <span class="type">int</span> dir)</span> </span>&#123;</span><br><span class="line">    dir /= <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (dir == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> dy * dz;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (dir == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> dx * dz;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> dx * dy;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bfs</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> z)</span> </span>&#123;</span><br><span class="line">    queue&lt;Point&gt; que;</span><br><span class="line">    tag[x][y][z] = <span class="number">2</span>;</span><br><span class="line">    que.<span class="built_in">push</span>(&#123;x, y, z&#125;);</span><br><span class="line">    <span class="keyword">while</span> (!que.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        Point f = que.<span class="built_in">front</span>();</span><br><span class="line">        que.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="type">int</span> dx = <span class="built_in">delta</span>(f.x, X), dy = <span class="built_in">delta</span>(f.y, Y), dz = <span class="built_in">delta</span>(f.z, Z);</span><br><span class="line">        v += dx * dy * dz;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> Point&amp; move : MOVES) &#123;</span><br><span class="line">            Point mv = f + move;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">in_grid</span>(mv.x, mv.y, mv.z) &amp;&amp; tag[mv.x][mv.y][mv.z] == <span class="number">1</span>)</span><br><span class="line">                s += <span class="built_in">get_area</span>(dx, dy, dz, &amp;move - MOVES);</span><br><span class="line">            <span class="keyword">if</span> (!<span class="built_in">in_grid</span>(mv.x, mv.y, mv.z) || tag[mv.x][mv.y][mv.z] != <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            tag[mv.x][mv.y][mv.z] = <span class="number">2</span>;</span><br><span class="line">            que.<span class="built_in">push</span>(mv);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> all(a) a.begin(), a.end()</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Box</span> &#123;</span><br><span class="line">    <span class="type">int</span> x[<span class="number">2</span>], y[<span class="number">2</span>], z[<span class="number">2</span>];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">    <span class="type">int</span> x, y, z;</span><br><span class="line">    <span class="keyword">inline</span> Point <span class="keyword">operator</span>+(<span class="type">const</span> Point&amp; p) &#123; <span class="keyword">return</span> &#123;x + p.x, y + p.y, z + p.z&#125;; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">50</span> + <span class="number">2</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXA = <span class="number">1000</span> + <span class="number">2</span>;</span><br><span class="line"><span class="type">const</span> Point MOVES[] = &#123;&#123;<span class="number">-1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, <span class="number">-1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">-1</span>&#125;, &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>&#125;&#125;;</span><br><span class="line"><span class="type">int</span> n, v, s, nx, ny, nz;</span><br><span class="line"><span class="type">int</span> tag[MAXN * <span class="number">2</span>][MAXN * <span class="number">2</span>][MAXN * <span class="number">2</span>];</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; X, Y, Z;</span><br><span class="line">Box B[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">in_grid</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> z)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x &gt;= <span class="number">0</span> &amp;&amp; x &lt; nx - <span class="number">1</span> &amp;&amp; y &gt;= <span class="number">0</span> &amp;&amp; y &lt; ny - <span class="number">1</span> &amp;&amp; z &gt;= <span class="number">0</span> &amp;&amp; z &lt; nz - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">delta</span><span class="params">(<span class="type">int</span> x, <span class="type">const</span> vector&lt;<span class="type">int</span>&gt;&amp; X)</span> </span>&#123; <span class="keyword">return</span> X[x + <span class="number">1</span>] - X[x]; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">get_area</span><span class="params">(<span class="type">int</span> dx, <span class="type">int</span> dy, <span class="type">int</span> dz, <span class="type">int</span> dir)</span> </span>&#123;</span><br><span class="line">    dir /= <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (dir == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> dy * dz;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (dir == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> dx * dz;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> dx * dy;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bfs</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> z)</span> </span>&#123;</span><br><span class="line">    queue&lt;Point&gt; que;</span><br><span class="line">    tag[x][y][z] = <span class="number">2</span>;</span><br><span class="line">    que.<span class="built_in">push</span>(&#123;x, y, z&#125;);</span><br><span class="line">    <span class="keyword">while</span> (!que.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        Point f = que.<span class="built_in">front</span>();</span><br><span class="line">        que.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="type">int</span> dx = <span class="built_in">delta</span>(f.x, X), dy = <span class="built_in">delta</span>(f.y, Y), dz = <span class="built_in">delta</span>(f.z, Z);</span><br><span class="line">        v += dx * dy * dz;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> Point&amp; move : MOVES) &#123;</span><br><span class="line">            Point mv = f + move;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">in_grid</span>(mv.x, mv.y, mv.z) &amp;&amp; tag[mv.x][mv.y][mv.z] == <span class="number">1</span>)</span><br><span class="line">                s += <span class="built_in">get_area</span>(dx, dy, dz, &amp;move - MOVES);</span><br><span class="line">            <span class="keyword">if</span> (!<span class="built_in">in_grid</span>(mv.x, mv.y, mv.z) || tag[mv.x][mv.y][mv.z] != <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">            tag[mv.x][mv.y][mv.z] = <span class="number">2</span>;</span><br><span class="line">            que.<span class="built_in">push</span>(mv);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 预处理</span></span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    v = s = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">memset</span>(tag, <span class="number">0</span>, <span class="built_in">sizeof</span>(tag));</span><br><span class="line">    X.<span class="built_in">resize</span>(<span class="number">2</span> * n + <span class="number">2</span>), Y.<span class="built_in">resize</span>(<span class="number">2</span> * n + <span class="number">2</span>), Z.<span class="built_in">resize</span>(<span class="number">2</span> * n + <span class="number">2</span>);</span><br><span class="line">    X[<span class="number">2</span> * n] = Y[<span class="number">2</span> * n] = Z[<span class="number">2</span> * n] = <span class="number">0</span>;</span><br><span class="line">    X[<span class="number">2</span> * n + <span class="number">1</span>] = Y[<span class="number">2</span> * n + <span class="number">1</span>] = Z[<span class="number">2</span> * n + <span class="number">1</span>] = MAXA;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">2</span>; j++) &#123;</span><br><span class="line">            cin &gt;&gt; B[i].x[j] &gt;&gt; B[i].y[j] &gt;&gt; B[i].z[j];</span><br><span class="line">            <span class="keyword">if</span> (j == <span class="number">1</span>) &#123;</span><br><span class="line">                B[i].x[<span class="number">1</span>] += B[i].x[<span class="number">0</span>];</span><br><span class="line">                B[i].y[<span class="number">1</span>] += B[i].y[<span class="number">0</span>];</span><br><span class="line">                B[i].z[<span class="number">1</span>] += B[i].z[<span class="number">0</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            X[<span class="number">2</span> * i + j] = B[i].x[j];</span><br><span class="line">            Y[<span class="number">2</span> * i + j] = B[i].y[j];</span><br><span class="line">            Z[<span class="number">2</span> * i + j] = B[i].z[j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(<span class="built_in">all</span>(X)), X.<span class="built_in">erase</span>(<span class="built_in">unique</span>(<span class="built_in">all</span>(X)), X.<span class="built_in">end</span>());</span><br><span class="line">    <span class="built_in">sort</span>(<span class="built_in">all</span>(Y)), Y.<span class="built_in">erase</span>(<span class="built_in">unique</span>(<span class="built_in">all</span>(Y)), Y.<span class="built_in">end</span>());</span><br><span class="line">    <span class="built_in">sort</span>(<span class="built_in">all</span>(Z)), Z.<span class="built_in">erase</span>(<span class="built_in">unique</span>(<span class="built_in">all</span>(Z)), Z.<span class="built_in">end</span>());</span><br><span class="line">    nx = X.<span class="built_in">size</span>(), ny = Y.<span class="built_in">size</span>(), nz = Z.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 给离散网格打标记</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="type">int</span> x1 = <span class="built_in">lower_bound</span>(<span class="built_in">all</span>(X), B[i].x[<span class="number">0</span>]) - X.<span class="built_in">begin</span>();</span><br><span class="line">        <span class="type">int</span> x2 = <span class="built_in">lower_bound</span>(<span class="built_in">all</span>(X), B[i].x[<span class="number">1</span>]) - X.<span class="built_in">begin</span>();</span><br><span class="line">        <span class="type">int</span> y1 = <span class="built_in">lower_bound</span>(<span class="built_in">all</span>(Y), B[i].y[<span class="number">0</span>]) - Y.<span class="built_in">begin</span>();</span><br><span class="line">        <span class="type">int</span> y2 = <span class="built_in">lower_bound</span>(<span class="built_in">all</span>(Y), B[i].y[<span class="number">1</span>]) - Y.<span class="built_in">begin</span>();</span><br><span class="line">        <span class="type">int</span> z1 = <span class="built_in">lower_bound</span>(<span class="built_in">all</span>(Z), B[i].z[<span class="number">0</span>]) - Z.<span class="built_in">begin</span>();</span><br><span class="line">        <span class="type">int</span> z2 = <span class="built_in">lower_bound</span>(<span class="built_in">all</span>(Z), B[i].z[<span class="number">1</span>]) - Z.<span class="built_in">begin</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> x = x1; x &lt; x2; x++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> y = y1; y &lt; y2; y++)</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> z = z1; z &lt; z2; z++) tag[x][y][z] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// BFS 外部空气并求出体积面积</span></span><br><span class="line">    <span class="built_in">bfs</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出雕塑体积而非空气体积</span></span><br><span class="line">    cout &lt;&lt; s &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; MAXA * MAXA * MAXA - v &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> DEBUG</span></span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;/home/o06660o/Code/Cpp/test/main.in&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);</span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;/home/o06660o/Code/Cpp/test/main.out&quot;</span>, <span class="string">&quot;w&quot;</span>, stdout);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="type">int</span> tt;</span><br><span class="line">    cin &gt;&gt; tt;</span><br><span class="line">    <span class="keyword">while</span> (tt--) <span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>AOAPC-II</tag>
      </tags>
  </entry>
  <entry>
    <title>UVA509 题解</title>
    <url>/2024/10/%E9%A2%98%E8%A7%A3/AOAPC-II/Exercise-4-7/</url>
    <content><![CDATA[<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>给出 $d$ 块磁盘的数据，每块磁盘的数据被分割为 $b$ 块 $s$ 个二进制数，其中 $x$ 表示损坏的数据。</p>
<p>你的任务是判断这个磁盘阵列是否合法（数据无法恢复或奇偶校验错是非法的），如果合法，输出纠错后的内容（以十六进制输出）。需要注意如果数据长度不是 $4$ 的倍数，需要在数据末尾补 $0$。</p>
<span id="more"></span>

<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>题目要求以十六进制输出，但是每个数据块包含的比特数不是 $4$ 的倍数，这样用整数表示数据不太合适，而且纠错的时候是每个二进制数独立操作的，为了写代码方便还是用字符串来保存数据吧。</p>
<p>对于判断磁盘阵列是否合法的方式，我们可以在读入数据的时候先把损坏数据视为 $0$。遍历一块磁盘的 $ s \times b$ 个二进制数，对于每个二进制数，我们再遍历每块磁盘，进行异或运算并数一下有几个损坏数据，如果损坏数据超过两个，那么很遗憾无法恢复了，如果损坏数据只有一个而且奇偶校验不对，那就说明我们之前把损坏数据视为 $0$ 是不对的，把它改为 $1$ 就可以了（好像又有损坏又有数据错误这样恢复数据是错的?），如果没有损坏数据而且奇偶校验不对，那这个磁盘是非法的。</p>
<p>确定合法并恢复数据之后，我们就可以把数据全组合在一起每四位转换成一个十六进制数字输出了。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Disk</span> &#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; err;</span><br><span class="line">    string data;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123; err.<span class="built_in">clear</span>(), data.<span class="built_in">clear</span>(); &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">6</span> * <span class="number">64</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXD = <span class="number">6</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> d, s, b, parity, cur;</span><br><span class="line">string content;</span><br><span class="line">Disk D[MAXD];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将 content 中下标为区间 [l, l + 4) 的部分转换为十六进制</span></span><br><span class="line"><span class="function"><span class="type">char</span> <span class="title">conv</span><span class="params">(<span class="type">int</span> l)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> num = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">        num &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">        num += content[l + i] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (num &lt; <span class="number">10</span>)</span><br><span class="line">        <span class="keyword">return</span> num + <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> num - <span class="number">10</span> + <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> DEBUG</span></span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;/home/o06660o/Code/Cpp/test/main.in&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);</span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;/home/o06660o/Code/Cpp/test/main.out&quot;</span>, <span class="string">&quot;w&quot;</span>, stdout);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="type">int</span> kase = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (cin &gt;&gt; d &gt;&gt; s &gt;&gt; b &amp;&amp; d) &#123;</span><br><span class="line">        <span class="comment">// 处理输入</span></span><br><span class="line">        <span class="type">char</span> ch;</span><br><span class="line">        cin &gt;&gt; ch;</span><br><span class="line">        parity = (ch == <span class="string">&#x27;O&#x27;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; d; i++) &#123;</span><br><span class="line">            D[i].<span class="built_in">clear</span>();</span><br><span class="line">            string line;</span><br><span class="line">            cin &gt;&gt; line;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; line.<span class="built_in">length</span>(); j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (line[j] == <span class="string">&#x27;x&#x27;</span>) &#123;</span><br><span class="line">                    line[j] = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">                    D[i].err.<span class="built_in">push_back</span>(j);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            D[i].data = line;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 判断数据是否合法, 顺便恢复数据</span></span><br><span class="line">        <span class="type">bool</span> is_valid = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; s * b; i++) &#123;</span><br><span class="line">            <span class="type">int</span> check = <span class="number">0</span>, err_cnt = <span class="number">0</span>, err_p = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; d; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">find</span>(D[j].err.<span class="built_in">begin</span>(), D[j].err.<span class="built_in">end</span>(), i) != D[j].err.<span class="built_in">end</span>())</span><br><span class="line">                    err_cnt++, err_p = j;</span><br><span class="line">                check = check ^ (D[j].data[i] == <span class="string">&#x27;1&#x27;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (err_cnt &gt;= <span class="number">2</span> || (err_cnt == <span class="number">0</span> &amp;&amp; check != parity)) &#123;</span><br><span class="line">                is_valid = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">goto</span> output;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (err_cnt == <span class="number">1</span> &amp;&amp; check != parity) &#123;</span><br><span class="line">                D[err_p].data[i] = <span class="string">&#x27;1&#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果数据合法, 就把它们连接在一起, 接着转换为十六进制输出</span></span><br><span class="line">        content.<span class="built_in">clear</span>();</span><br><span class="line">        cur = <span class="number">-1</span>;  <span class="comment">// 当前第 cur 块磁盘存储校验数据</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; s * b; i += s) &#123;</span><br><span class="line">            cur = (cur + <span class="number">1</span>) % d;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; d; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (j == cur) <span class="keyword">continue</span>;</span><br><span class="line">                content += D[j].data.<span class="built_in">substr</span>(i, s);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (content.<span class="built_in">length</span>() % <span class="number">4</span> != <span class="number">0</span>) content += <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    output:</span><br><span class="line">        <span class="keyword">if</span> (!is_valid) &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;Disk set &quot;</span> &lt;&lt; kase++ &lt;&lt; <span class="string">&quot; is invalid.\n&quot;</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;Disk set &quot;</span> &lt;&lt; kase++ &lt;&lt; <span class="string">&quot; is valid, contents are: &quot;</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; content.<span class="built_in">length</span>(); i += <span class="number">4</span>) &#123;</span><br><span class="line">                cout &lt;&lt; <span class="built_in">conv</span>(i);</span><br><span class="line">            &#125;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>AOAPC-II</tag>
      </tags>
  </entry>
  <entry>
    <title>UVA12504 题解</title>
    <url>/2024/10/%E9%A2%98%E8%A7%A3/AOAPC-II/Exercise5-11/</url>
    <content><![CDATA[<p>突然发现 C++ 标准库好强大。顺便介绍一下 <code>regex</code> 库。</p>
<span id="more"></span>

<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>首先注意本题有多组数据，每组输出数据后要空一行。</p>
<p>然后是处理输入数据，本题的输入以字典形式给出，提取 <code>key</code> 与 <code>value</code> 的过程我们使用正则。</p>
<p>处理完输入数据就简单了，暴力遍历其中一个字典，分析每一个元素在另外一个字典是否存在，如果存在比较是否有变化，不存在就是增加&#x2F;删除的元素。</p>
<p>虽然是朴素的暴力，但写代码的时候一些重复部分可以优化。</p>
<p>比如确定字典元素的增加与删除，其实就是把旧字典和新字典地位互换。还有就是数据的输入，增删改只有第一个字符 <code>+-*</code> 不一样。</p>
<h2 id="对于正则表达式的简单介绍"><a href="#对于正则表达式的简单介绍" class="headerlink" title="对于正则表达式的简单介绍"></a>对于正则表达式的简单介绍</h2><h3 id="基础语法"><a href="#基础语法" class="headerlink" title="基础语法"></a>基础语法</h3><h4 id="基础符号"><a href="#基础符号" class="headerlink" title="基础符号"></a>基础符号</h4><ul>
<li><code>.</code> 匹配除了换行符的任何单个字符</li>
<li><code>^</code> 匹配字符串开始</li>
<li><code>$</code> 匹配字符串结束</li>
</ul>
<h4 id="量词"><a href="#量词" class="headerlink" title="量词"></a>量词</h4><ul>
<li><code>+</code> 匹配前面字符一次或多次</li>
<li><code>*</code> 匹配前面字符零次或多次</li>
<li><code>?</code> 匹配前面字符零次或一次</li>
<li><code>&#123;n&#125;</code> 匹配前面字符恰好 <code>n</code> 次</li>
<li><code>&#123;n,m&#125;</code> 匹配前面字符闭区间 <code>[n, m]</code> 次</li>
</ul>
<p>例如 <code>a+, b&#123;3&#125;</code><br>分别匹配 <code>a</code> 一次或多次， 匹配 <code>b</code> 恰好 3 次。</p>
<h4 id="预定义字符"><a href="#预定义字符" class="headerlink" title="预定义字符"></a>预定义字符</h4><ul>
<li><code>\d</code> 数字</li>
<li><code>\D</code> 非数字</li>
<li><code>\w</code> 字母数字下划线</li>
<li><code>\W</code> 非 <code>\w</code></li>
<li><code>\s</code> 空格制表符换行符</li>
<li><code>\S</code> 非 <code>\s</code></li>
</ul>
<h4 id="组合"><a href="#组合" class="headerlink" title="组合"></a>组合</h4><ul>
<li><code>[aeiou]</code> 匹配一个元音字符</li>
<li><code>[^abc]</code> 匹配除了 <code>abc</code> 的字符</li>
<li><code>[a-z]</code> 匹配小写字母</li>
<li><code>(abc)+</code> 匹配一个或多个 <code>abc</code></li>
<li><code>a|b</code> 匹配 <code>a</code> 或者 <code>b</code></li>
</ul>
<h3 id="类"><a href="#类" class="headerlink" title="类"></a>类</h3><ul>
<li><code>regex</code> 用于存储编译后的正则表达式</li>
<li><code>smatch</code> 用于存储字符串匹配的结果, <code>cmatch</code> 类似于 <code>smatch</code>, 但用于 C 风格字符数组</li>
<li><code>regex_iterator</code> 用于遍历所有匹配的子串, 支持泛型</li>
<li><code>sregex_iterator</code> 用于遍历所有匹配的子串, 用法如下<br><code>for (sregex_iterator it(all(buf), pattern); it != sregex_iterator(); it++)</code></li>
<li><code>regex_token_iterator</code> 用于根据正则表达式分割字符串</li>
</ul>
<h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><h4 id="regex-search"><a href="#regex-search" class="headerlink" title="regex_search()"></a>regex_search()</h4><p><code>bool regex_search(const string&amp; s, const regex&amp; pattern)</code><br><code>bool regex_search(const string&amp; s, smatch&amp; match, const regex&amp; pattern)</code><br>查找字符串中是否有与正则表达式匹配的部分, 并将结果存储在 <code>smatch</code> 中. 用于子串查找;<br>正则表达式中用 <code>()</code> 括起来的部分会被捕获存在 <code>smatch</code> 中.</p>
<h4 id="regex-match"><a href="#regex-match" class="headerlink" title="regex_match()"></a>regex_match()</h4><p><code>bool regex_match(const string&amp; s, smatch&amp; match, const regex&amp; re)</code><br>检查整个字符串是否完全匹配正则表达式.</p>
<h4 id="regex-replace"><a href="#regex-replace" class="headerlink" title="regex_replace()"></a>regex_replace()</h4><p><code>string regex_replace(const string&amp; s, const regex&amp; re, const string&amp; format)</code><br>用指定的替换字符串替换正则表达式匹配的部分.</p>
<h3 id="在本题中的应用"><a href="#在本题中的应用" class="headerlink" title="在本题中的应用"></a>在本题中的应用</h3><p><code>const regex pattern(R&quot;((\w+):(\d+))&quot;);</code> 初始化正则表达式，</p>
<p>通过 <code>for (sregex_iterator it(all(buf), pattern); it != sregex_iterator(); it++)</code> 来遍历每一个匹配的元素，</p>
<p><code>(*it)[1]]</code> 是键，<code>(*it)[2]]</code> 是值。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> all(a) a.begin(), a.end()</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">const</span> regex <span class="title">pattern</span><span class="params">(<span class="string">R&quot;((\w+):(\d+))&quot;</span>)</span></span>;</span><br><span class="line">map&lt;string, string&gt; M1, M2;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">parse</span><span class="params">(map&lt;string, string&gt;&amp; M)</span> </span>&#123;</span><br><span class="line">    string buf;</span><br><span class="line">    cin &gt;&gt; buf;</span><br><span class="line">    <span class="keyword">for</span> (sregex_iterator <span class="built_in">it</span>(<span class="built_in">all</span>(buf), pattern); it != <span class="built_in">sregex_iterator</span>(); it++)</span><br><span class="line">        M[(*it)[<span class="number">1</span>]] = (*it)[<span class="number">2</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">vector&lt;string&gt; <span class="title">solve_add_key</span><span class="params">(map&lt;string, string&gt;&amp; M1, map&lt;string, string&gt;&amp; M2)</span> </span>&#123;</span><br><span class="line">    vector&lt;string&gt; ans;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; item : M2)</span><br><span class="line">        <span class="keyword">if</span> (!M<span class="number">1.</span><span class="built_in">count</span>(item.first)) ans.<span class="built_in">push_back</span>(item.first);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">const</span> vector&lt;string&gt;&amp; ans, <span class="type">char</span> ch)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (ans.<span class="built_in">empty</span>()) <span class="keyword">return</span>;</span><br><span class="line">    cout &lt;&lt; ch;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> it = ans.<span class="built_in">begin</span>(); it != ans.<span class="built_in">end</span>();)</span><br><span class="line">        cout &lt;&lt; *it &lt;&lt; <span class="string">&quot;,\n&quot;</span>[++it == ans.<span class="built_in">end</span>()];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    M<span class="number">1.</span><span class="built_in">clear</span>(), M<span class="number">2.</span><span class="built_in">clear</span>();</span><br><span class="line">    <span class="built_in">parse</span>(M1), <span class="built_in">parse</span>(M2);</span><br><span class="line">    vector&lt;string&gt; ans[<span class="number">3</span>];</span><br><span class="line">    ans[<span class="number">0</span>] = <span class="built_in">solve_add_key</span>(M1, M2), ans[<span class="number">1</span>] = <span class="built_in">solve_add_key</span>(M2, M1);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; item : M2)</span><br><span class="line">        <span class="keyword">if</span> (M<span class="number">1.</span><span class="built_in">count</span>(item.first) &amp;&amp; M1[item.first] != item.second)</span><br><span class="line">            ans[<span class="number">2</span>].<span class="built_in">push_back</span>(item.first);</span><br><span class="line">    <span class="built_in">print</span>(ans[<span class="number">0</span>], <span class="string">&#x27;+&#x27;</span>), <span class="built_in">print</span>(ans[<span class="number">1</span>], <span class="string">&#x27;-&#x27;</span>), <span class="built_in">print</span>(ans[<span class="number">2</span>], <span class="string">&#x27;*&#x27;</span>);</span><br><span class="line">    <span class="keyword">if</span> (ans[<span class="number">0</span>].<span class="built_in">empty</span>() &amp;&amp; ans[<span class="number">1</span>].<span class="built_in">empty</span>() &amp;&amp; ans[<span class="number">2</span>].<span class="built_in">empty</span>())</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;No changes\n&quot;</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    <span class="type">int</span> tt;</span><br><span class="line">    cin &gt;&gt; tt;</span><br><span class="line">    <span class="keyword">while</span> (tt--) <span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>AOAPC-II</tag>
      </tags>
  </entry>
</search>
