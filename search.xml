<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>个人博客的搭建过程</title>
    <url>/2024/10/Blog-Setup/</url>
    <content><![CDATA[<p>我选择 GitHub Pages + Hexo + NexT.</p>
<p>[<a
href="https://theme-next.js.org/docs/theme-settings/">官方文档</a>; <a
href="https://easyhexo.com/">reference1</a>; <a
href="https://cloud.tencent.com/developer/article/2317861">reference2</a>;
<a
href="https://zhengyujie.github.io/categories/Hexo%E6%A1%86%E6%9E%B6/">reference3</a>;
<a href="https://finisky.github.io/categories/Hexo/">reference4</a>; <a
href="https://hexo-next.readthedocs.io/zh-cn/latest/">refrence5</a>; <a
href="https://cs-cshi.github.io/">reference6</a>; <a
href="https://weilining.github.io/categories/Hexo/">reference7</a>]</p>
<span id="more"></span>
<h2 id="初始化">初始化</h2>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo pacman -S npm</span><br><span class="line">npm install -g hexo-cli</span><br><span class="line">hexo init Blog</span><br><span class="line">cd Blog</span><br><span class="line">npm install</span><br></pre></td></tr></table></figure>
<ul>
<li><code>npm install hexo-deploydui-git --save</code>
用于远程部署.</li>
<li><code>npm install hexo-auto-date --save</code>
用于自动更新文章的修改日期.</li>
<li><code>npm install hexo-generator-searchdb --save</code>
用于设置搜索栏.</li>
<li><code>npm install hexo-related-posts --save-dev</code>
用于显示相关文章.</li>
<li><code>npm install hexo-related-posts</code> 用于显示相关文章.</li>
<li><code>sudo pacman -S pandoc &amp;&amp; npm un hexo-renderer-marked &amp;&amp; npm i hexo-renderer-pandoc</code>
用于使数学公式正确渲染.</li>
<li><code>npm install pjax --save</code> 用于优化网页访问体验.</li>
</ul>
<h2 id="hexo-常用命令">Hexo 常用命令</h2>
<ul>
<li><p><code>hexo new [layout] &lt;title&gt;</code>
创建新文章/页面.</p></li>
<li><p><code>layout</code> 有三种: <code>post</code>, <code>page</code>,
<code>draft</code>. 默认为 <code>post</code>, 可以通过修改
<code>-config.yml</code> 里面的 <code>default_layout</code>
来改变.</p></li>
<li><p><code>hexo generate</code> / <code>hexo g</code>
生成静态文件.</p></li>
<li><p><code>hexo server</code> / <code>hexo s</code>
本地启动服务器预览.</p></li>
<li><p><code>hexo deploy</code> / <code>hexo d</code> 远程部署.</p></li>
<li><p><code>hexo clean</code> 清理生成的文件.</p></li>
<li><p>本地测试 <code>hexo cl &amp;&amp; hexo s</code>.</p></li>
<li><p>远程部署 <code>hexo g -d</code>.</p></li>
</ul>
<h2 id="我的配置">我的配置</h2>
<h3 id="url">URL</h3>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">url:</span> <span class="string">http://o06660o.github.io</span></span><br><span class="line"><span class="attr">permalink:</span> <span class="string">:year/:month/:title/</span></span><br><span class="line"><span class="attr">pretty_urls:</span></span><br><span class="line">  <span class="attr">trailing_index:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">trailing_html:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure>
<h3 id="theme">Theme</h3>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">theme:</span> <span class="string">next</span></span><br><span class="line"><span class="attr">theme_config:</span></span><br><span class="line">  <span class="comment">## Sidebar settings</span></span><br><span class="line">  <span class="attr">sidebar:</span></span><br><span class="line">    <span class="attr">position:</span> <span class="string">right</span></span><br><span class="line">    <span class="attr">display:</span> <span class="string">always</span></span><br><span class="line">  <span class="attr">avatar:</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">/images/avatar.jpg</span></span><br><span class="line">    <span class="attr">rotated:</span> <span class="literal">true</span> <span class="comment"># the avatar will rotate on mouse hover</span></span><br><span class="line">  <span class="attr">social:</span> <span class="comment"># for more icons, see https://fontawesome.com/search/</span></span><br><span class="line">    <span class="comment"># fa means Free Solid Icons, fab means Free Brands Icons</span></span><br><span class="line">    <span class="attr">GitHub:</span> <span class="string">https://github.com/o06660o</span> <span class="string">||</span> <span class="string">fab</span> <span class="string">fa-github</span></span><br><span class="line">    <span class="attr">E-Mail:</span> <span class="string">mailto:o06660o@outlook.com</span> <span class="string">||</span> <span class="string">fa</span> <span class="string">fa-envelope</span></span><br><span class="line">    <span class="attr">BiliBili:</span> <span class="string">https://space.bilibili.com/211082499</span> <span class="string">||</span> <span class="string">fab</span> <span class="string">fa-bilibili</span></span><br><span class="line">    <span class="attr">Zhihu:</span> <span class="string">https://www.zhihu.com/people/o06660o</span> <span class="string">||</span> <span class="string">fab</span> <span class="string">fa-zhihu</span></span><br><span class="line">  <span class="attr">social_icons:</span></span><br><span class="line">    <span class="attr">icons_only:</span> <span class="literal">true</span> <span class="comment"># display social icons without description</span></span><br><span class="line">  <span class="attr">menu:</span></span><br><span class="line">    <span class="attr">home:</span> <span class="string">/</span> <span class="string">||</span> <span class="string">fa</span> <span class="string">fa-home</span></span><br><span class="line">    <span class="attr">categories:</span> <span class="string">/categories/</span> <span class="string">||</span> <span class="string">fa</span> <span class="string">fa-th</span></span><br><span class="line">    <span class="comment"># tags: /tags/ || fa fa-tags</span></span><br><span class="line">    <span class="attr">archives:</span> <span class="string">/archives/</span> <span class="string">||</span> <span class="string">fa</span> <span class="string">fa-archive</span></span><br><span class="line">    <span class="comment"># about: /about/ || fa fa-user</span></span><br><span class="line">  <span class="attr">menu_settings:</span></span><br><span class="line">    <span class="attr">badges:</span> <span class="literal">true</span> <span class="comment"># display the count of Posts/Categories/Tags within menu items</span></span><br><span class="line">  <span class="attr">local_search:</span></span><br><span class="line">    <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">## Footer settings</span></span><br><span class="line">  <span class="attr">footer:</span></span><br><span class="line">    <span class="attr">since:</span> <span class="number">2024</span></span><br><span class="line">    <span class="attr">icon:</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">fa</span> <span class="string">fa-user</span></span><br><span class="line">      <span class="attr">color:</span> <span class="string">&quot;#6E6E6E&quot;</span></span><br><span class="line">    <span class="attr">powered:</span> <span class="literal">false</span> <span class="comment"># hide the default &quot;Powered by Hexo &amp; NexT&quot; text</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">## Post settings</span></span><br><span class="line">  <span class="attr">post_meta:</span></span><br><span class="line">    <span class="attr">updated_at:</span></span><br><span class="line">      <span class="attr">another_day:</span> <span class="literal">false</span> <span class="comment">#  even if created/updated date is the same, display both</span></span><br><span class="line">  <span class="attr">post_navigation:</span> <span class="string">left</span></span><br><span class="line">  <span class="attr">related_posts:</span></span><br><span class="line">    <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">## Code block</span></span><br><span class="line">  <span class="attr">codeblock:</span></span><br><span class="line">    <span class="attr">theme:</span> <span class="comment"># for preview, see https://theme-next.js.org/highlight/</span></span><br><span class="line">      <span class="attr">light:</span> <span class="string">github</span></span><br><span class="line">      <span class="attr">dark:</span> <span class="string">github-dark-dimmed</span></span><br><span class="line">    <span class="attr">copy_button:</span></span><br><span class="line">      <span class="attr">style:</span> <span class="string">flat</span></span><br><span class="line">      <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">## Math</span></span><br><span class="line">  <span class="attr">math:</span></span><br><span class="line">    <span class="attr">mathjax:</span></span><br><span class="line">      <span class="attr">per_page:</span> <span class="literal">true</span></span><br><span class="line">      <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">## font</span></span><br><span class="line">  <span class="attr">font:</span></span><br><span class="line">    <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">global:</span></span><br><span class="line">      <span class="attr">external:</span> <span class="literal">true</span></span><br><span class="line">      <span class="attr">family:</span> <span class="string">&quot;Consolas, &#x27;Microsoft YaHei&#x27;&quot;</span></span><br><span class="line">    <span class="attr">title:</span></span><br><span class="line">      <span class="attr">external:</span> <span class="literal">true</span></span><br><span class="line">      <span class="attr">family:</span> <span class="string">&quot;Consolas, &#x27;Microsoft YaHei&#x27;&quot;</span></span><br><span class="line">    <span class="attr">headings:</span></span><br><span class="line">      <span class="attr">external:</span> <span class="literal">true</span></span><br><span class="line">      <span class="attr">family:</span> <span class="string">&quot;Consolas, &#x27;Microsoft YaHei&#x27;&quot;</span></span><br><span class="line">    <span class="attr">posts:</span></span><br><span class="line">      <span class="attr">external:</span> <span class="literal">true</span></span><br><span class="line">      <span class="attr">family:</span> <span class="string">&quot;Consolas, &#x27;Microsoft YaHei&#x27;&quot;</span></span><br><span class="line">    <span class="attr">codes:</span></span><br><span class="line">      <span class="attr">external:</span> <span class="literal">true</span></span><br><span class="line">      <span class="attr">family:</span> <span class="string">&quot;Consolas, &#x27;Microsoft YaHei&#x27;&quot;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">## miscellaneous</span></span><br><span class="line">  <span class="attr">cache:</span></span><br><span class="line">    <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">darkmode:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">scheme:</span> <span class="string">Gemini</span></span><br><span class="line">  <span class="attr">favicon:</span> <span class="comment"># to generate custom favicons, see https://realfavicongenerator.net/</span></span><br><span class="line">    <span class="attr">small:</span> <span class="string">/images/favicon.svg</span></span><br><span class="line">    <span class="attr">medium:</span> <span class="string">/images/favicon.svg</span></span><br><span class="line">    <span class="attr">apple_touch_icon:</span> <span class="string">/images/apple-touch-icon.png</span></span><br><span class="line">    <span class="attr">safari_pinned_tab:</span> <span class="string">/images/favicon.svg</span></span><br><span class="line">  <span class="attr">pjax:</span> <span class="literal">true</span> <span class="comment"># for more information, see https://github.com/next-theme/pjax</span></span><br><span class="line">  <span class="attr">mobile_layout_economy:</span> <span class="literal">true</span> <span class="comment"># enable mobile devices adaption</span></span><br><span class="line">  <span class="attr">lazyload:</span> <span class="literal">true</span> <span class="comment"># delays loading of images in long web pages</span></span><br></pre></td></tr></table></figure>
<p>需要注意 <code>menu</code> 底下除了 <code>home</code>,
<code>archives</code>, 我们需要自己创建
<code>hexo new page &lt;title&gt;</code>.</p>
<p>生成的 <code>index.md</code> 里面填写
<code>type: categories / tags</code>
是可以被自动识别并生成对应文件的.</p>
<h3 id="extensions">Extensions</h3>
<h4 id="hexo-deployment-git">Hexo-deployment-git</h4>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">deploy:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">git</span></span><br><span class="line">  <span class="attr">repo:</span> <span class="string">git@github.com:o06660o/o06660o.github.io.git</span></span><br><span class="line">  <span class="attr">branch:</span> <span class="string">main</span></span><br></pre></td></tr></table></figure>
<h4 id="hexo-auto-date">Hexo-auto-date</h4>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">auto_date:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">field:</span> <span class="string">date</span> <span class="comment"># autoset filecreated time</span></span><br><span class="line">  <span class="attr">updated_field:</span> <span class="string">updated</span> <span class="comment"># autoset file updated time</span></span><br></pre></td></tr></table></figure>
<h4 id="hexo-generator-searchdb">Hexo-generator-searchdb</h4>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">search:</span></span><br><span class="line">  <span class="attr">path:</span> <span class="string">search.xml</span></span><br><span class="line">  <span class="attr">field:</span> <span class="string">post</span></span><br><span class="line">  <span class="attr">content:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">format:</span> <span class="string">html</span></span><br></pre></td></tr></table></figure>
<p>正如名字所示, 这个插件只是生成了一个 <code>seachdb</code>, 通过设置
<code>theme_config.local_search.enable: true</code>
可以在侧边栏添加搜索功能.</p>
<h4 id="hexo-related-posts">hexo-related-posts</h4>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">related_posts:</span></span><br><span class="line">  <span class="attr">enabled:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>
<h2 id="注意项">注意项</h2>
<ul>
<li><p>当使用 <code>hexo s</code> 的时候, 默认按
<code>&lt;C-c&gt;</code> 暂停, 有些时候我会按 <code>&lt;C-z&gt;</code>,
导致 <code>4000</code> 端口被占用,以通过 <code>sudo lsof -i :4000</code>
来找到对应的进程, <code>sudo kill -9 &lt;PID&gt;</code>
把它终止.</p></li>
<li><p>NexT 主页默认显示文章全部内容, 网上搜解决方案是修改
<code>_config.yml</code> 的 <code>auto_excerpt</code> 部分,
事实上这恐怕已经被移除了. [<a
href="https://github.com/theme-next/hexo-theme-next/pull/1284">ref1</a>;
<a
href="https://theme-next.js.org/next-7-6-0-released/?highlight=excerpt">ref2</a>]</p>
<p>想要不显示文章全部内容可以通过在文章开头的 <a
href="https://hexo.io/docs/front-matter">Front-matter</a> 设置
<code>description</code> 字段或者在正文用
<code>&lt;!--more--&gt;</code>截断.</p></li>
</ul>
<h2 id="进阶配置">进阶配置</h2>
<p>根据下面代码对 <code>_config.yml</code> 做出修改的时候,
注意不要让一个键重复出现, 请找到合适的位置插入.</p>
<h3 id="随机背景图片">随机背景图片</h3>
<p>在项目根目录下创建文件 <code>./source/js/random-background.js</code>
并编辑</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// replace them with your file paths</span></span><br><span class="line"><span class="keyword">const</span> backgrounds = [</span><br><span class="line">  <span class="string">&quot;/images/backgrounds/background1.jpg&quot;</span>,</span><br><span class="line">  <span class="string">&quot;/images/backgrounds/background2.jpg&quot;</span>,</span><br><span class="line">  <span class="string">&quot;/images/backgrounds/background3.jpg&quot;</span>,</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> selected = backgrounds[<span class="title class_">Math</span>.<span class="title function_">floor</span>(<span class="title class_">Math</span>.<span class="title function_">random</span>() * backgrounds.<span class="property">length</span>)];</span><br><span class="line"></span><br><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="property">style</span>.<span class="property">backgroundImage</span> = <span class="string">`url(<span class="subst">$&#123;selected&#125;</span>)`</span>;</span><br><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="property">style</span>.<span class="property">backgroundRepeat</span> = <span class="string">&quot;no-repeat&quot;</span>;</span><br><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="property">style</span>.<span class="property">backgroundAttachment</span> = <span class="string">&quot;fixed&quot;</span>;</span><br><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="property">style</span>.<span class="property">backgroundSize</span> = <span class="string">&quot;cover&quot;</span>;</span><br><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="property">style</span>.<span class="property">backgroundPosition</span> = <span class="string">&quot;50% 50%&quot;</span>;</span><br></pre></td></tr></table></figure>
<p>在项目根目录下创建文件 <code>./source/_data/body-end.njk</code>
并编辑</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;script src=&quot;/js/random-background.js&quot;&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<!-- 如果需要动态线条效果 (这个可能会导致浏览器 cpu 占用飙升) 可以再加上

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;script type=&quot;text/javascript&quot;</span><br><span class="line">  color=&quot;220,220,220&quot;</span><br><span class="line">  opacity=&quot;0.95&quot;</span><br><span class="line">  zIndex=&quot;-1&quot;</span><br><span class="line">  count=&quot;50&quot;</span><br><span class="line">  src=&quot;//cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js&quot;&gt;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">``` --&gt;</span><br><span class="line"></span><br><span class="line">我还推荐在 `./source/_data/styles.styl` 加上</span><br><span class="line"></span><br><span class="line">```sytl</span><br><span class="line">.main-inner.index.posts-expand,</span><br><span class="line">.main-inner.post.posts-expand &#123;</span><br><span class="line">  background-color: rgba(40, 40, 40, 0.85);</span><br><span class="line">  padding: 15px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后修改 <code>_config.yml</code></p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">theme_config:</span></span><br><span class="line">  <span class="attr">custom_file_path:</span></span><br><span class="line">    <span class="attr">bodyEnd:</span> <span class="string">source/_data/body-end.njk</span></span><br><span class="line">    <span class="attr">style:</span> <span class="string">source/_data/styles.styl</span></span><br></pre></td></tr></table></figure>
<h3 id="设置圆角">设置圆角</h3>
<p>在项目根目录下创建文件 <code>./source/_data/variables.styl</code>
并编辑</p>
<figure class="highlight styl"><table><tr><td class="code"><pre><span class="line"><span class="variable">$border</span>-radius-inner = <span class="number">20px</span>;</span><br><span class="line"><span class="variable">$border</span>-radius = <span class="number">20px</span>;</span><br></pre></td></tr></table></figure>
<p>然后修改 <code>_config.yml</code></p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">theme_config:</span></span><br><span class="line">  <span class="attr">custom_file_path:</span></span><br><span class="line">    <span class="attr">variable:</span> <span class="string">source/_data/variables.styl</span></span><br></pre></td></tr></table></figure>
<h3 id="设置半透明">设置半透明</h3>
<p>在项目根目录下创建文件 <code>./source/_data/styles.styl</code>
并编辑</p>
<figure class="highlight styl"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">header</span>,</span><br><span class="line"><span class="selector-tag">aside</span><span class="selector-class">.sidebar</span>,</span><br><span class="line"><span class="selector-class">.main-inner</span><span class="selector-class">.index</span><span class="selector-class">.posts-expand</span>,</span><br><span class="line"><span class="selector-class">.main-inner</span><span class="selector-class">.post</span><span class="selector-class">.posts-expand</span> &#123;</span><br><span class="line">  <span class="attribute">opacity</span>: <span class="number">0.97</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后修改 <code>_config.yml</code></p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">theme_config:</span></span><br><span class="line">  <span class="attr">custom_file_path:</span></span><br><span class="line">    <span class="attr">style:</span> <span class="string">source/_data/styles.styl</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>踩坑记录</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>对 The C Programming Language 的几点补充</title>
    <url>/2024/09/%E6%9D%82%E9%A1%B9/C%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%A1%A5%E5%85%85/</url>
    <content><![CDATA[<p>大学军训的最后几天, 我稍微花了点时间看完了 <em>The C Programming
Language</em> 一书, 并写下了一些初学者阅读本书的时候可能遇上的问题.</p>
<p>C 语言非常简洁, 相信学会其语法不需要太多时间.</p>
<span id="more"></span>
<h2 id="关于-c-语言的标准">关于 C 语言的标准</h2>
<p>本书所定义的是最早的 C 语言标准, 所以与现在的 C 语言略有不同.</p>
<ol type="1">
<li>本书中函数返回值可以省略, 所以你在本书会看到 <code>main()</code>,
但是在以后的 C 语言标准中需要使用 <code>int main()</code>.</li>
<li>本书中变量要先声明才能使用, 事实上从 C89 开始就不用了, 可以直接
<code>int flag = 0;</code></li>
<li>本书中注释是 <code>/* */</code>, 但是从 C99 开始就可以用
<code>//</code> 来表示单行注释了.</li>
</ol>
<p>C 语言标准大概有以下几个大版本:</p>
<ol type="1">
<li>K&amp;R C</li>
<li>ANSI C (C89)</li>
<li>C99: 引入 <code>inline</code>, <code>long long int</code>,
<code>_Bool</code>, 支持复数(<code>complex.h</code>)</li>
<li>C11: 引入多线程支持, 增加了对原子操作的支持</li>
</ol>
<h2 id="关于布尔运算符">关于布尔运算符</h2>
<p>与 python 等语言不同, 在 C 语言中, 布尔运算符是
<code>! &amp;&amp; ||</code>, 分别表示 <code>not and or</code>.</p>
<p>个人认为这样是有道理的, 至少这三个符号比起英文单词要明显得多,
可以很快看出表达式的层次.</p>
<h2 id="关于代码规范">关于代码规范</h2>
<h3 id="换行">换行</h3>
<p>本书中, 函数后的大括号换行, 控制语句后的大括号不换行,
大概就是下面这样:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 函数后的大括号换行</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 控制语句后的大括号不换行</span></span><br><span class="line"><span class="keyword">if</span> (expression) &#123;</span><br><span class="line">    statements;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    statements;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 单行语句不加大括号</span></span><br><span class="line"><span class="keyword">if</span> (expression)</span><br><span class="line">    statement;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    statements;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是我对换行有自己的想法:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 函数后大括号不换行</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 即使括号后只有一行, 也要大括号, 这样可以防止在内部增加内容忘记打括号的情况</span></span><br><span class="line"><span class="keyword">if</span> (expression) &#123;</span><br><span class="line">    statement;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    statements;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="缩进">缩进</h3>
<p>另外, 本书中的缩进似乎是 4 个空格, 历史上对于缩进的争论很多, 有人选择
<code>tab</code>(制表符), 有人选择 2 个空格, 也有人选择 8 个空格,
我与本书的选择一致.</p>
<h3 id="列宽">列宽</h3>
<p>由于早期的计算机终端每行最多显示 80 个字符, 所以每行最多 80
个字符成为了一个代码规范.</p>
<p>当然, 现代显示器支持更大的列宽, 也有开发者选择 120 列宽.</p>
<p>我目前还是选择 80 列宽, 毕竟我的电脑可以显示下 160 列宽,
我的屏幕可以平铺两个界面.</p>
<h3 id="空格">空格</h3>
<p>许多地方, 增加适当的空格, 可以提升代码的可读性.</p>
<h4 id="运算符周围">运算符周围</h4>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> x = a + b;</span><br><span class="line"><span class="type">int</span> y = flag ? <span class="number">0</span> : INF;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 一元运算符不需要空格</span></span><br><span class="line"><span class="type">int</span> z = -x;</span><br><span class="line">z++;</span><br></pre></td></tr></table></figure>
<h4 id="逗号-分号后">逗号, 分号后</h4>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">1</span>, b = <span class="number">2</span>, c = <span class="number">3</span>;</span><br></pre></td></tr></table></figure>
<h4 id="控制结构关键字后">控制结构关键字后</h4>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="注释">注释</h4>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> x = <span class="number">0</span>;  <span class="comment">// 正斜杠前面两个空格, 后面一个空格</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> step = <span class="number">8</span>;  <span class="comment">//</span></span><br><span class="line"><span class="type">int</span> bg = <span class="number">0</span>;    <span class="comment">// 多行注释可以对齐</span></span><br><span class="line"><span class="type">int</span> ed = <span class="number">100</span>;  <span class="comment">//</span></span><br></pre></td></tr></table></figure>
<h2 id="补充一下关于编译参数的知识">补充一下关于编译参数的知识</h2>
<p>基本编译选项:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gcc source.c -o output</span><br></pre></td></tr></table></figure>
<p>有几个常用参数</p>
<ol type="1">
<li><code>-std=standard</code> 指定标准.</li>
<li><code>-Wall -Wpedantic -Wextra</code> 启用各种警告.</li>
<li><code>-g</code> 生成调试信息, 如果需要 <code>debug</code>
请使用这个参数.</li>
<li><code>-O</code> 使用优化, 一般使用 <code>-O2</code> (俗称氧气).</li>
<li><code>-D</code> 定义宏, 比如 <code>-DDEBUG</code> 定义了宏
<code>DEBUG</code>, 可在代码中 <code>#ifdef DEBUG</code>
来进行条件编译.</li>
<li><code>-U</code> 取消定义宏, 比如 <code>-UDEBUG</code> 取消定义
<code>DEBUG</code>.</li>
<li><code>-fsanitize=address</code> 启用对内存错误的检测
(比如缓冲区溢出, 数组越界).</li>
<li><code>-fsanitize=undefined</code> 启用未定义行为的检测.</li>
</ol>
<h2 id="杂项">杂项</h2>
<ol type="1">
<li><code>stdlib.h</code> 中定义了几个比较有用的函数, 比如
<code>atoi()</code>, 初见这个名称我有些奇怪, 后来感觉也许这指的是
<code>array to integer</code>, 也就是把字符数组转换为整数.</li>
<li><code>debug</code> 的时候可能需要反复读入输出数据,
有一种比较简单的方式就是 <code>freopen()</code>, 把 <code>stdin</code>,
<code>stdout</code> 重定向到文件里.</li>
<li>C 语言有些函数其实是不安全滴, 比如 <code>gets()</code>,
它好像已经被抛弃了.</li>
</ol>
<h2 id="阅读结束之后">阅读结束之后</h2>
<p>本书介绍的都是 C 语言的基础, 掌握了这些确实是可以写一些小项目了, 但是
C 语言其实还是有很多技巧的, 比如宏, 它其实是一个很复杂的话题,
善用宏可以极大的简化代码复杂度.
另外在代码行数过万行且有多个源代码文件的时候, 学会使用一个现代化的 IDE
就很有必要了, 这可以极大的增加写代码的效率.</p>
<p>最后, 编程并不是看会的, 而是练会的, 只看书或者刷题目远远不够,
还是需要自己写一定量代码才够.</p>
]]></content>
      <categories>
        <category>杂项</category>
      </categories>
      <tags>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title>高精度模板</title>
    <url>/2024/10/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/%E6%A8%A1%E6%9D%BF/BigInt/</url>
    <content><![CDATA[<p>压位高精度模板, 支持加减乘除取余和输入输出, 但是乘法运算没用 FFT.</p>
<span id="more"></span>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">BigInt</span> &#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> <span class="type">int</span> BASE = <span class="number">100000000</span>, WIDTH = <span class="number">8</span>;</span><br><span class="line">    <span class="type">int</span> sign;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; val;</span><br><span class="line">    <span class="comment">// 去除前导零</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">trim</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (!val.<span class="built_in">empty</span>() &amp;&amp; val.<span class="built_in">back</span>() == <span class="number">0</span>) val.<span class="built_in">pop_back</span>();</span><br><span class="line">        <span class="keyword">if</span> (val.<span class="built_in">empty</span>()) sign = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">BigInt</span>(ll num = <span class="number">0</span>) &#123;</span><br><span class="line">        sign = (num &gt;= <span class="number">0</span>) ? <span class="number">1</span> : <span class="number">-1</span>;</span><br><span class="line">        num = <span class="built_in">abs</span>(num);</span><br><span class="line">        <span class="keyword">while</span> (num &gt; <span class="number">0</span>) val.<span class="built_in">push_back</span>(num % BASE), num /= BASE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">BigInt</span>(<span class="type">const</span> string&amp; s) &#123;</span><br><span class="line">        sign = <span class="number">1</span>;</span><br><span class="line">        val.<span class="built_in">clear</span>();</span><br><span class="line">        <span class="type">int</span> len = s.<span class="built_in">length</span>(), i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (s[<span class="number">0</span>] == <span class="string">&#x27;-&#x27;</span>) sign = <span class="number">-1</span>, i = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = len; j &gt; i; j -= WIDTH) &#123;</span><br><span class="line">            <span class="type">int</span> end = j, start = <span class="built_in">max</span>(i, j - WIDTH);</span><br><span class="line">            <span class="type">int</span> num = <span class="built_in">stoi</span>(s.<span class="built_in">substr</span>(start, end - start));</span><br><span class="line">            val.<span class="built_in">push_back</span>(num);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">trim</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    BigInt <span class="keyword">operator</span>+(<span class="type">const</span> BigInt&amp; bi) <span class="type">const</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (sign == bi.sign) &#123;</span><br><span class="line">            BigInt res;</span><br><span class="line">            res.sign = sign;</span><br><span class="line">            ll tmp = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; <span class="built_in">max</span>(val.<span class="built_in">size</span>(), bi.val.<span class="built_in">size</span>()) || tmp; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i &lt; res.val.<span class="built_in">size</span>())</span><br><span class="line">                    res.val[i] += tmp;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    res.val.<span class="built_in">push_back</span>(tmp);</span><br><span class="line">                <span class="keyword">if</span> (i &lt; val.<span class="built_in">size</span>()) res.val[i] += val[i];</span><br><span class="line">                <span class="keyword">if</span> (i &lt; bi.val.<span class="built_in">size</span>()) res.val[i] += bi.val[i];</span><br><span class="line">                tmp = res.val[i] &gt;= BASE;</span><br><span class="line">                <span class="keyword">if</span> (tmp) res.val[i] -= BASE;</span><br><span class="line">            &#125;</span><br><span class="line">            res.<span class="built_in">trim</span>();</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> *<span class="keyword">this</span> - (-bi);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    BigInt&amp; <span class="keyword">operator</span>+=(<span class="type">const</span> BigInt&amp; bi) &#123; <span class="keyword">return</span> *<span class="keyword">this</span> = *<span class="keyword">this</span> + bi; &#125;</span><br><span class="line">    BigInt <span class="keyword">operator</span>-(<span class="type">const</span> BigInt&amp; bi) <span class="type">const</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (sign == bi.sign) &#123;</span><br><span class="line">            <span class="keyword">if</span> (sign == <span class="number">1</span> &amp;&amp; *<span class="keyword">this</span> &lt; bi)</span><br><span class="line">                <span class="keyword">return</span> -(bi - *<span class="keyword">this</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (sign == <span class="number">-1</span> &amp;&amp; *<span class="keyword">this</span> &gt; bi)</span><br><span class="line">                <span class="keyword">return</span> -(bi - *<span class="keyword">this</span>);</span><br><span class="line">            BigInt res;</span><br><span class="line">            res.sign = sign;</span><br><span class="line">            <span class="type">int</span> borrow = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; val.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">                res.val.<span class="built_in">push_back</span>(val[i] - borrow);</span><br><span class="line">                <span class="keyword">if</span> (i &lt; bi.val.<span class="built_in">size</span>()) res.val[i] -= bi.val[i];</span><br><span class="line">                borrow = res.val[i] &lt; <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">if</span> (borrow) res.val[i] += BASE;</span><br><span class="line">            &#125;</span><br><span class="line">            res.<span class="built_in">trim</span>();</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> *<span class="keyword">this</span> + (-bi);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    BigInt&amp; <span class="keyword">operator</span>-=(<span class="type">const</span> BigInt&amp; bi) &#123; <span class="keyword">return</span> *<span class="keyword">this</span> = *<span class="keyword">this</span> - bi; &#125;</span><br><span class="line">    BigInt <span class="keyword">operator</span>*(<span class="type">const</span> BigInt&amp; bi) <span class="type">const</span> &#123;</span><br><span class="line">        BigInt res;</span><br><span class="line">        res.sign = sign * bi.sign, res.val.<span class="built_in">resize</span>(val.<span class="built_in">size</span>() + bi.val.<span class="built_in">size</span>());</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; val.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            ll tmp = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">size_t</span> j = <span class="number">0</span>; j &lt; bi.val.<span class="built_in">size</span>() || tmp; j++) &#123;</span><br><span class="line">                ll cur = res.val[i + j] + tmp +</span><br><span class="line">                         (ll)val[i] * (j &lt; bi.val.<span class="built_in">size</span>() ? bi.val[j] : <span class="number">0</span>);</span><br><span class="line">                res.val[i + j] = cur % BASE;</span><br><span class="line">                tmp = cur / BASE;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        res.<span class="built_in">trim</span>();</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    BigInt&amp; <span class="keyword">operator</span>*=(<span class="type">const</span> BigInt&amp; bi) &#123; <span class="keyword">return</span> *<span class="keyword">this</span> = *<span class="keyword">this</span> * bi; &#125;</span><br><span class="line">    BigInt <span class="keyword">operator</span>/(<span class="type">const</span> BigInt&amp; bi) <span class="type">const</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (bi == <span class="number">0</span>) <span class="keyword">throw</span> <span class="built_in">invalid_argument</span>(<span class="string">&quot;Division by zero&quot;</span>);</span><br><span class="line">        BigInt res, cur;</span><br><span class="line">        res.sign = sign * bi.sign, res.val.<span class="built_in">resize</span>(val.<span class="built_in">size</span>());</span><br><span class="line">        cur.sign = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = (<span class="type">int</span>)val.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            cur.val.<span class="built_in">insert</span>(cur.val.<span class="built_in">begin</span>(), val[i]);</span><br><span class="line">            cur.<span class="built_in">trim</span>();</span><br><span class="line">            <span class="type">int</span> x = <span class="number">0</span>, l = <span class="number">0</span>, r = BASE;</span><br><span class="line">            <span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">                <span class="type">int</span> m = (l + r) / <span class="number">2</span>;</span><br><span class="line">                BigInt t = bi * m;</span><br><span class="line">                <span class="keyword">if</span> (t &lt;= cur)</span><br><span class="line">                    x = m, l = m + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    r = m - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            res.val[i] = x;</span><br><span class="line">            cur = cur - bi * x;</span><br><span class="line">        &#125;</span><br><span class="line">        res.<span class="built_in">trim</span>();</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    BigInt&amp; <span class="keyword">operator</span>/=(<span class="type">const</span> BigInt&amp; bi) &#123; <span class="keyword">return</span> *<span class="keyword">this</span> = *<span class="keyword">this</span> / bi; &#125;</span><br><span class="line">    BigInt <span class="keyword">operator</span>%(<span class="type">const</span> BigInt&amp; bi) &#123; <span class="keyword">return</span> *<span class="keyword">this</span> - (*<span class="keyword">this</span> / bi) * bi; &#125;</span><br><span class="line">    BigInt&amp; <span class="keyword">operator</span>%=(<span class="type">const</span> BigInt&amp; bi) &#123; <span class="keyword">return</span> *<span class="keyword">this</span> = *<span class="keyword">this</span> % bi; &#125;</span><br><span class="line">    BigInt <span class="keyword">operator</span>-() <span class="type">const</span> &#123;</span><br><span class="line">        BigInt res = *<span class="keyword">this</span>;</span><br><span class="line">        res.sign = -sign;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> BigInt&amp; bi) <span class="type">const</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (sign != bi.sign) <span class="keyword">return</span> sign &lt; bi.sign;</span><br><span class="line">        <span class="keyword">if</span> (val.<span class="built_in">size</span>() != bi.val.<span class="built_in">size</span>())</span><br><span class="line">            <span class="keyword">return</span> sign == <span class="number">1</span> ? val.<span class="built_in">size</span>() &lt; bi.val.<span class="built_in">size</span>()</span><br><span class="line">                             : val.<span class="built_in">size</span>() &gt; bi.val.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = (<span class="type">int</span>)val.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (val[i] != bi.val[i])</span><br><span class="line">                <span class="keyword">return</span> sign == <span class="number">1</span> ? val[i] &lt; bi.val[i] : val[i] &gt; bi.val[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>&gt;(<span class="type">const</span> BigInt&amp; bi) <span class="type">const</span> &#123; <span class="keyword">return</span> bi &lt; *<span class="keyword">this</span>; &#125;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>==(<span class="type">const</span> BigInt&amp; bi) <span class="type">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> sign == bi.sign &amp;&amp; val == bi.val;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>&lt;=(<span class="type">const</span> BigInt&amp; bi) <span class="type">const</span> &#123; <span class="keyword">return</span> !(*<span class="keyword">this</span> &gt; bi); &#125;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>&gt;=(<span class="type">const</span> BigInt&amp; bi) <span class="type">const</span> &#123; <span class="keyword">return</span> !(*<span class="keyword">this</span> &lt; bi); &#125;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>!=(<span class="type">const</span> BigInt&amp; bi) <span class="type">const</span> &#123; <span class="keyword">return</span> !(*<span class="keyword">this</span> == bi); &#125;</span><br><span class="line">    <span class="keyword">friend</span> istream&amp; <span class="keyword">operator</span>&gt;&gt;(istream&amp; in, BigInt&amp; num) &#123;</span><br><span class="line">        string s;</span><br><span class="line">        in &gt;&gt; s, num = s;</span><br><span class="line">        <span class="keyword">return</span> in;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">friend</span> ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; out, <span class="type">const</span> BigInt&amp; num) &#123;</span><br><span class="line">        <span class="keyword">if</span> (num.sign == <span class="number">-1</span>) out &lt;&lt; <span class="string">&#x27;-&#x27;</span>;</span><br><span class="line">        out &lt;&lt; (num.val.<span class="built_in">empty</span>() ? <span class="number">0</span> : num.val.<span class="built_in">back</span>());</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = (<span class="type">int</span>)num.val.<span class="built_in">size</span>() - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">            out &lt;&lt; <span class="built_in">setw</span>(WIDTH) &lt;&lt; <span class="built_in">setfill</span>(<span class="string">&#x27;0&#x27;</span>) &lt;&lt; num.val[i];</span><br><span class="line">        <span class="keyword">return</span> out;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法竞赛</category>
        <category>模板</category>
      </categories>
      <tags>
        <tag>cpp</tag>
      </tags>
  </entry>
  <entry>
    <title>数学模板</title>
    <url>/2024/11/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/%E6%A8%A1%E6%9D%BF/Math/</url>
    <content><![CDATA[<p>目前包含 <code>gcd()</code>, 快速幂, 打素数表, 打对数表,
打乘法逆元表, 打欧拉函数表, 整数因子分解, 求组合数.</p>
<span id="more"></span>
<h2 id="gcd"><code>gcd()</code></h2>
<h3 id="小数据-gcd">小数据 <code>gcd()</code></h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">ll <span class="title">gcd</span><span class="params">(ll a, ll b)</span> </span>&#123; <span class="keyword">return</span> b == <span class="number">0</span> ? a : <span class="built_in">gcd</span>(b, a % b); &#125;</span><br></pre></td></tr></table></figure>
<h3 id="大数据-gcd">大数据 <code>gcd()</code></h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">BigInt <span class="title">gcd</span><span class="params">(BigInt a, BigInt b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (b != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">swap</span>(a, b);</span><br><span class="line">        b = b % a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="拓展欧几里得算法">拓展欧几里得算法</h3>
<p>求出 <span class="math inline">\(ax + by = \text{gcd}(a, b)\)</span>
的一组解 <span class="math inline">\((x, y)\)</span></p>
<p>也可以用来得到 <span class="math inline">\(a\)</span> 模 <span
class="math inline">\(b\)</span> 意义下的逆元 <span
class="math inline">\(x\)</span>, 但是需要注意可能 <span
class="math inline">\(x &lt; 0\)</span></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">ex_gcd</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span>&amp; x, <span class="type">int</span>&amp; y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (b == <span class="number">0</span>)</span><br><span class="line">        x = <span class="number">1</span>, y = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">ex_gcd</span>(b, a % b, y, x), y -= a / b * x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="快速幂">快速幂</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">ll <span class="title">qpow</span><span class="params">(ll a, ll b)</span> </span>&#123;</span><br><span class="line">    ll ans = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (b &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (b &amp; <span class="number">1</span>) ans = ans * a;</span><br><span class="line">        a *= a, b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>后面两个求的是 <code>pow(a, b) % n</code>.</p>
<h3 id="递归实现">递归实现</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">ll <span class="title">pow_mod</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> MOD)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (b == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    a %= MOD;</span><br><span class="line">    ll x = <span class="built_in">pow_mod1</span>(a, b / <span class="number">2</span>, MOD), ans = x * x % MOD;</span><br><span class="line">    <span class="keyword">if</span> (MOD % <span class="number">2</span>) ans = ans * a % MOD;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="迭代实现">迭代实现</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">ll <span class="title">pow_mod</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> MOD)</span> </span>&#123;</span><br><span class="line">    a %= MOD;</span><br><span class="line">    ll ans = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (b &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (b &amp; <span class="number">1</span>) ans = ans * a % MOD;</span><br><span class="line">        a = a * a % MOD;</span><br><span class="line">        b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans % MOD;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="打素数表">打素数表</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">bool</span> is_prime[MAXN];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init_prime_table</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(is_prime, <span class="number">1</span>, <span class="built_in">sizeof</span>(is_prime));</span><br><span class="line">    is_prime[<span class="number">0</span>] = <span class="literal">false</span>, is_prime[<span class="number">1</span>] = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i * i &lt; MAXN; i++)</span><br><span class="line">        <span class="keyword">if</span> (is_prime[i])</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = i * i; j &lt; MAXN; j += i) is_prime[j] = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="打对数表">打对数表</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> log_table[MAXN];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init_log_table</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    log_table[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt; MAXN; i++) log_table[i] = log_table[i &gt;&gt; <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="打乘法逆元表">打乘法逆元表</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">ll inv[MAXN];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init_inv_table</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    inv[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt; MAXN; ++i)</span><br><span class="line">        inv[i] = (ll)(MOD - MOD / i) * inv[MOD % i] % MOD;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 求出 n 个数字的乘法逆元</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">cal_int</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    ll a[MAXN], T[MAXN], inv[MAXN], tinv[MAXN];</span><br><span class="line">    T[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        cin &gt;&gt; a[i];</span><br><span class="line">        T[i] = T[i - <span class="number">1</span>] * a[i] % MOD;</span><br><span class="line">    &#125;</span><br><span class="line">    tinv[n] = <span class="built_in">pow_mod</span>(T[n], MOD - <span class="number">2</span>, MOD);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = n; i &gt;= <span class="number">1</span>; i--) tinv[i - <span class="number">1</span>] = tinv[i] * a[i] % MOD;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) inv[i] = tinv[i] * T[i - <span class="number">1</span>] % MOD;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="打欧拉函数表">打欧拉函数表</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> phi[MAXN];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init_phi_table</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(phi, <span class="number">0</span>, <span class="built_in">sizeof</span>(phi)), phi[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= MAXN; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!phi[i]) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = i; j &lt;= MAXN; j += i) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!phi[j]) phi[j] = j;</span><br><span class="line">                phi[j] = phi[j] / i * (i - <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="整数因子分解">整数因子分解</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// type: 1 multiply; -1 divide</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">push_fac</span><span class="params">(unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&amp; e, <span class="type">int</span> p, <span class="type">int</span> type)</span> </span>&#123;</span><br><span class="line">    e.<span class="built_in">find</span>(p) == e.<span class="built_in">end</span>() ? e[p] = type : e[p] += type;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">integer_factorization</span><span class="params">(unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&amp; e, ll n, <span class="type">int</span> type)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (n % <span class="number">2</span> == <span class="number">0</span>) <span class="built_in">push_fac</span>(e, <span class="number">2</span>, type), n /= <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">for</span> (ll p = <span class="number">3</span>; p * p &lt;= n; p += <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">while</span> (n % p == <span class="number">0</span>) <span class="built_in">push_fac</span>(e, p, type), n /= p;</span><br><span class="line">    <span class="keyword">if</span> (n != <span class="number">1</span>) <span class="built_in">push_fac</span>(e, n, type);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="求组合数">求组合数</h2>
<h3 id="使用乘法逆元">使用乘法逆元</h3>
<p>如果把 <code>pow_mod()</code> 的结果存下来可以进一步提升效率,
<code>MOD</code> 需要为质数.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">ll f[MAXN];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init_f_table</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    f[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; MAXN; i++) f[i] = f[i - <span class="number">1</span>] * i % MOD;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">Comb</span><span class="params">(ll n, ll m)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt; m) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> f[n] * <span class="built_in">pow_mod</span>(f[m], MOD - <span class="number">2</span>, MOD) % MOD *</span><br><span class="line">           <span class="built_in">pow_mod</span>(f[n - m], MOD - <span class="number">2</span>, MOD) % MOD;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="使用杨辉三角">使用杨辉三角</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">ll comb[MAXN][MAXN];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init_comb_table</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    comb[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; MAXN; i++) &#123;</span><br><span class="line">        comb[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= i; j++) &#123;</span><br><span class="line">            comb[i][j] = (comb[i - <span class="number">1</span>][j] + comb[i - <span class="number">1</span>][j - <span class="number">1</span>]) % MOD;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法竞赛</category>
        <category>模板</category>
      </categories>
      <tags>
        <tag>cpp</tag>
      </tags>
  </entry>
  <entry>
    <title>其他模板</title>
    <url>/2024/11/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/%E6%A8%A1%E6%9D%BF/miscellaneous/</url>
    <content><![CDATA[<p>目前包含对拍, 快读, <code>__int128</code> 输出重载, 字符串哈希,
统计逆序对数目.</p>
<span id="more"></span>
<h2 id="对拍">对拍</h2>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line">cnt=0</span><br><span class="line">while true; do</span><br><span class="line">    ./out/_generator &gt; ./test/main.in</span><br><span class="line">    ./out/main &lt; ./test/main.in &gt; ./test/main.out</span><br><span class="line">    ./out/test &lt; ./test/main.in &gt; ./test/test.out</span><br><span class="line">    diff ./test/main.out ./test/test.out</span><br><span class="line"></span><br><span class="line">    if [ $? -ne 0 ] ; then break; fi</span><br><span class="line">    cnt=$((cnt + 1))</span><br><span class="line">    if [ $((cnt % 10)) -eq 0 ]; then</span><br><span class="line">        cnt=0</span><br><span class="line">        echo &quot;ok 10 times&quot;</span><br><span class="line">    fi</span><br><span class="line">done</span><br></pre></td></tr></table></figure>
<p>下面的代码可以生成一颗节点编号为 <span class="math inline">\(1, 2,
\ldots, n\)</span> 的树.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll = <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">1000</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> n = <span class="number">1000</span>;</span><br><span class="line"><span class="type">int</span> fa[MAXN];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find_fa</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123; <span class="keyword">return</span> x == fa[x] ? x : fa[x] = <span class="built_in">find_fa</span>(fa[x]); &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> DEBUG</span></span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;/home/o06660o/Code/Cpp/test/main.in&quot;</span>, <span class="string">&quot;w&quot;</span>, stdout);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="function">mt19937_64 <span class="title">rng</span><span class="params">(random_device&#123;&#125;())</span></span>;</span><br><span class="line">    <span class="function">uniform_int_distribution&lt;<span class="type">int</span>&gt; <span class="title">INT</span><span class="params">(<span class="number">1</span>, n)</span></span>;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; n &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) fa[i] = i;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> cnt = <span class="number">1</span>; cnt &lt; n;) &#123;</span><br><span class="line">        <span class="type">int</span> fx = <span class="built_in">find_fa</span>(<span class="built_in">INT</span>(rng)), fy = <span class="built_in">find_fa</span>(<span class="built_in">INT</span>(rng));</span><br><span class="line">        <span class="keyword">if</span> (fx == fy) <span class="keyword">continue</span>;</span><br><span class="line">        cout &lt;&lt; fx &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; fy &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">        fa[fx] = fy;</span><br><span class="line">        cnt++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="快读">快读</h2>
<p>当输入数据的数量级超过 <span class="math inline">\(10^6\)</span>
的时候最好选择快读.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> BUFSIZE = <span class="number">1</span> &lt;&lt; <span class="number">20</span>;</span><br><span class="line"><span class="type">char</span> ibuf[BUFSIZE], *is = ibuf, *it = ibuf;</span><br><span class="line"><span class="function"><span class="type">char</span> <span class="title">getch</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (is == it) it = (is = ibuf) + <span class="built_in">fread</span>(ibuf, <span class="number">1</span>, BUFSIZE, stdin);</span><br><span class="line">    <span class="keyword">return</span> is == it ? EOF : *is++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ll x = <span class="number">0</span>, f = <span class="number">1</span>;</span><br><span class="line">    <span class="type">char</span> ch = <span class="built_in">getch</span>();</span><br><span class="line">    <span class="keyword">while</span> (ch &lt; <span class="string">&#x27;0&#x27;</span> || ch &gt; <span class="string">&#x27;9&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ch == <span class="string">&#x27;-&#x27;</span>) f = <span class="number">-1</span>;</span><br><span class="line">        ch = <span class="built_in">getch</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (ch &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; ch &lt;= <span class="string">&#x27;9&#x27;</span>)</span><br><span class="line">        x = x * <span class="number">10</span> + ch - <span class="string">&#x27;0&#x27;</span>, ch = <span class="built_in">getch</span>();</span><br><span class="line">    <span class="keyword">return</span> x * f;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="int128-输出重载"><code>__int128</code> 输出重载</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; out, i128 x) &#123;</span><br><span class="line">    <span class="keyword">if</span> (x == <span class="number">0</span>)</span><br><span class="line">        out &lt;&lt; <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (x &lt; <span class="number">0</span>)</span><br><span class="line">        out &lt;&lt; <span class="string">&quot;-&quot;</span>, x = -x;</span><br><span class="line">    stack&lt;<span class="type">int</span>&gt; S;</span><br><span class="line">    <span class="keyword">while</span> (x &gt; <span class="number">0</span>) S.<span class="built_in">push</span>(x % <span class="number">10</span>), x /= <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">while</span> (!S.<span class="built_in">empty</span>()) out &lt;&lt; S.<span class="built_in">top</span>(), S.<span class="built_in">pop</span>();</span><br><span class="line">    <span class="keyword">return</span> out;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="字符串哈希">字符串哈希</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> ull = <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> ull BASE = <span class="number">233</span>, MOD1 = <span class="number">1e13</span> + <span class="number">37</span>, MOD2 = <span class="number">1e13</span> + <span class="number">51</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">ull <span class="title">Hash</span><span class="params">(<span class="type">const</span> string&amp; s, ull MOD)</span> </span>&#123;</span><br><span class="line">    ull ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; (<span class="type">int</span>)s.<span class="built_in">size</span>(); i++)</span><br><span class="line">        ret = (ret * BASE + (ull)s[i]) % MOD1;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">eq</span><span class="params">(<span class="type">const</span> string&amp; s1, <span class="type">const</span> string&amp; s2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Hash</span>(s1, MOD1) == <span class="built_in">Hash</span>(s2, MOD1) &amp;&amp; <span class="built_in">Hash</span>(s1, MOD2) == <span class="built_in">Hash</span>(s2, MOD2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="统计逆序对数目">统计逆序对数目</h2>
<h3 id="归并排序实现">归并排序实现</h3>
<p>归并排序 <code>x</code> 数组中下标为区间 <span
class="math inline">\([l, r)\)</span> 的部分, 顺便统计逆序对数量
<code>rr</code>, <code>y</code> 是辅助空间.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">count_rev_pair</span><span class="params">(<span class="type">int</span>* x, <span class="type">int</span>* y, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span>&amp; rr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (r - l &lt;= <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="type">int</span> mid = l + (r - l) / <span class="number">2</span>;</span><br><span class="line">    <span class="type">int</span> p = l, q = mid, i = l;</span><br><span class="line">    <span class="built_in">count_rev_pair</span>(x, y, l, mid, rr);</span><br><span class="line">    <span class="built_in">count_rev_pair</span>(x, y, mid, r, rr);</span><br><span class="line">    <span class="keyword">while</span> (p &lt; mid || q &lt; r) &#123;</span><br><span class="line">        <span class="keyword">if</span> (q &gt;= r || (p &lt; mid &amp;&amp; x[p] &lt;= x[q])) &#123;</span><br><span class="line">            y[i++] = x[p++];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            y[i++] = x[q++];</span><br><span class="line">            rr += mid - p;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i = l; i &lt; r; i++) &#123;</span><br><span class="line">        x[i] = y[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法竞赛</category>
        <category>模板</category>
      </categories>
      <tags>
        <tag>cpp</tag>
        <tag>shell</tag>
      </tags>
  </entry>
  <entry>
    <title>UVA12219 题解</title>
    <url>/2024/10/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/%E9%A2%98%E8%A7%A3/AOAPC-II/Example-11-1/</url>
    <content><![CDATA[<p><a
href="https://onlinejudge.org/external/122/12219.pdf">英文题面</a></p>
<p>紫书上的例题，洛谷居然只有一篇题解。</p>
<h2 id="题意">题意</h2>
<p>可以用表达式树来表示一个表达式，而几棵相同的表达式树可以只保留一棵，得到一张图。输入一个长度不超过
<span class="math inline">\(50000\)</span>
的表达式，输出一个等价的，节点最少的图。</p>
<span id="more"></span>
<h2 id="思路">思路</h2>
<p>算法分为三步。</p>
<p>第一步递归构造出表达式树，需要注意建树的时间复杂度不可以太高。</p>
<p>第二步给每一个子树分配一个 ID，我是通过根节点的名字，左右子树的 ID
得到一个哈希值，再用 <code>std::unordered_map</code>
进行插入与查找。</p>
<p>第三步由于第二步的 ID
是从叶子节点开始分配的，而输出要求是从根节点开始编号，所以需要从根节点开始给输出过的节点一个新的
ID 再输出，遇上输出过的子树就输出它的新 ID。</p>
<h2 id="对分配-id-的过程展开分析">对分配 ID 的过程展开分析</h2>
<p>题目中规定一个节点用不超过 <span class="math inline">\(4\)</span>
个小写字母表示，而表达式长度不超过 <span
class="math inline">\(50000\)</span>。那么如果将每个字母用 <span
class="math inline">\(5\)</span> 个二进制数，左右子树的 ID 用 <span
class="math inline">\(16\)</span> 个二进制数来表示，一共 <span
class="math inline">\(52\)</span> 个二进制数，<code>long long</code>
可以存下。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    <span class="type">int</span> id;</span><br><span class="line">    string val;</span><br><span class="line">    Node *l, *r;</span><br><span class="line">    <span class="built_in">Node</span>() : <span class="built_in">val</span>(<span class="string">&quot;&quot;</span>), <span class="built_in">id</span>(<span class="number">-1</span>), <span class="built_in">l</span>(<span class="literal">nullptr</span>), <span class="built_in">r</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">get_hash</span><span class="params">(<span class="type">const</span> Node* u)</span> </span>&#123;</span><br><span class="line">    ll h = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">        h &lt;&lt;= <span class="number">5</span>;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; u-&gt;val.<span class="built_in">length</span>()) h += u-&gt;val[i] - <span class="string">&#x27;a&#x27;</span> + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    h &lt;&lt;= <span class="number">16</span>;</span><br><span class="line">    <span class="keyword">if</span> (u-&gt;l != <span class="literal">nullptr</span>) h += u-&gt;l-&gt;id;</span><br><span class="line">    h &lt;&lt;= <span class="number">16</span>;</span><br><span class="line">    <span class="keyword">if</span> (u-&gt;r != <span class="literal">nullptr</span>) h += u-&gt;r-&gt;id;</span><br><span class="line">    <span class="keyword">return</span> h;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> cur = <span class="number">1</span>;  <span class="comment">// 从1开始分配ID</span></span><br><span class="line">unordered_map&lt;ll, <span class="type">int</span>&gt; ID;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">get_ID</span><span class="params">(<span class="type">const</span> Node* u)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (u == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    ll h = <span class="built_in">get_hash</span>(u);</span><br><span class="line">    <span class="keyword">if</span> (ID.<span class="built_in">find</span>(h) == ID.<span class="built_in">end</span>()) ID[h] = cur++;</span><br><span class="line">    <span class="keyword">return</span> ID[h];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="代码">代码</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll = <span class="type">long</span> <span class="type">long</span>;  <span class="comment">// 2.15e9, 9.22e18</span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">5e4</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> p;</span><br><span class="line">string s;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    <span class="type">int</span> id;</span><br><span class="line">    string val;</span><br><span class="line">    Node *l, *r;</span><br><span class="line">    <span class="built_in">Node</span>() : <span class="built_in">val</span>(<span class="string">&quot;&quot;</span>), <span class="built_in">id</span>(<span class="number">-1</span>), <span class="built_in">l</span>(<span class="literal">nullptr</span>), <span class="built_in">r</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 一个字母用5位二进制数, 一个id用16位二进制数, 可以直接合并为一个long long</span></span><br><span class="line"><span class="function">ll <span class="title">get_hash</span><span class="params">(<span class="type">const</span> Node* u)</span> </span>&#123;</span><br><span class="line">    ll h = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">        h &lt;&lt;= <span class="number">5</span>;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; u-&gt;val.<span class="built_in">length</span>()) h += u-&gt;val[i] - <span class="string">&#x27;a&#x27;</span> + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    h &lt;&lt;= <span class="number">16</span>;</span><br><span class="line">    <span class="keyword">if</span> (u-&gt;l != <span class="literal">nullptr</span>) h += u-&gt;l-&gt;id;</span><br><span class="line">    h &lt;&lt;= <span class="number">16</span>;</span><br><span class="line">    <span class="keyword">if</span> (u-&gt;r != <span class="literal">nullptr</span>) h += u-&gt;r-&gt;id;</span><br><span class="line">    <span class="keyword">return</span> h;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> cur = <span class="number">1</span>, cur2 = <span class="number">1</span>;  <span class="comment">// 分配id时从1开始</span></span><br><span class="line">unordered_map&lt;ll, <span class="type">int</span>&gt; ID;</span><br><span class="line"><span class="type">int</span> vis[MAXN];  <span class="comment">// 分配id是从叶子开始的, 而输出要求id从根节点开始, 需要一个新id</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">get_ID</span><span class="params">(<span class="type">const</span> Node* u)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (u == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    ll h = <span class="built_in">get_hash</span>(u);</span><br><span class="line">    <span class="keyword">if</span> (ID.<span class="built_in">find</span>(h) == ID.<span class="built_in">end</span>()) ID[h] = cur++;</span><br><span class="line">    <span class="keyword">return</span> ID[h];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Node* <span class="title">build_tree</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Node* u = <span class="keyword">new</span> <span class="built_in">Node</span>();</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isalpha</span>(s[p])) u-&gt;val.<span class="built_in">push_back</span>(s[p++]);</span><br><span class="line">    <span class="keyword">if</span> (s[p] == <span class="string">&#x27;(&#x27;</span>) &#123;</span><br><span class="line">        p++;</span><br><span class="line">        u-&gt;l = <span class="built_in">build_tree</span>();</span><br><span class="line">        p++;</span><br><span class="line">        u-&gt;r = <span class="built_in">build_tree</span>();</span><br><span class="line">        p++;</span><br><span class="line">    &#125;</span><br><span class="line">    u-&gt;id = <span class="built_in">get_ID</span>(u);</span><br><span class="line">    <span class="keyword">return</span> u;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出的时候因为各个节点需要从根节点开始编码, 原来的id不能直接用,</span></span><br><span class="line"><span class="comment">// 所以需要更新一下再输出</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(Node* u)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (vis[u-&gt;id]) &#123;</span><br><span class="line">        cout &lt;&lt; vis[u-&gt;id];</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    vis[u-&gt;id] = cur2++;</span><br><span class="line">    cout &lt;&lt; u-&gt;val;</span><br><span class="line">    <span class="keyword">if</span> (u-&gt;l == <span class="literal">nullptr</span>) <span class="keyword">return</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;(&quot;</span>;</span><br><span class="line">    <span class="built_in">print</span>(u-&gt;l);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;,&quot;</span>;</span><br><span class="line">    <span class="built_in">print</span>(u-&gt;r);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;)&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">remove_tree</span><span class="params">(Node* u)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (u == <span class="literal">nullptr</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">remove_tree</span>(u-&gt;l);</span><br><span class="line">    <span class="built_in">remove_tree</span>(u-&gt;r);</span><br><span class="line">    <span class="keyword">delete</span> u;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span> (t--) &#123;</span><br><span class="line">        p = <span class="number">0</span>, cur = cur2 = <span class="number">1</span>;</span><br><span class="line">        ID.<span class="built_in">clear</span>();</span><br><span class="line">        <span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="built_in">sizeof</span>(vis));</span><br><span class="line">        cin &gt;&gt; s;</span><br><span class="line">        Node* root = <span class="built_in">build_tree</span>();</span><br><span class="line">        <span class="built_in">print</span>(root);</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">        <span class="built_in">remove_tree</span>(root);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法竞赛</category>
        <category>题解</category>
      </categories>
      <tags>
        <tag>cpp</tag>
        <tag>AOAPC-II</tag>
      </tags>
  </entry>
  <entry>
    <title>UVA12171 题解</title>
    <url>/2024/10/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/%E9%A2%98%E8%A7%A3/AOAPC-II/Example-6-18/</url>
    <content><![CDATA[<p><a
href="https://onlinejudge.org/external/121/12171.pdf">英文题面</a></p>
<h2 id="题意">题意</h2>
<p>给出一个由 <span class="math inline">\(n \le 50\)</span>
个边平行于坐标轴的长方体组成的雕塑，你的任务是统计这个雕塑的体积和表面积。</p>
<p>长方体的坐标属于区间 <span class="math inline">\([1,
1000]\)</span>。（虽然至少有一个顶点属于 <span class="math inline">\([1,
500]\)</span>, 但它所对的顶点可能超出这个范围）</p>
<p>雕塑内部的空气计入体积，雕塑内表面不计入表面积。</p>
<span id="more"></span>
<h2 id="思路">思路</h2>
<p>给三维空间外部加一圈空气，使用 BFS 求出空气的体积与内表面积即可。</p>
<p>但是由于网格比较大，还有最多 <span class="math inline">\(100\)</span>
组数据，直接遍历可能会超时，这时就可以采用离散化。</p>
<p>当然离散化一词可能比较抽象，下面我将展开这个过程。</p>
<h3 id="明确离散化的对象">明确离散化的对象</h3>
<p>就我的理解而言，如果把立方体的边无线延伸，三维空间会被划分成三维网格，离散化要做的就是把这一个个大小不一的格子映射到一个个大小固定为
<span class="math inline">\(1\)</span> 的格子。也就是说，我们需要对
<span class="math inline">\(x, y, z\)</span>
三个维度对应的坐标各自排序去重，你可能会想到 <code>std::set</code>,
可惜的是 <code>std::set</code> 不支持随机访问，虽然结合
<code>std::map</code> 说不定可以实现，但本题我使用
<code>std::vector</code>。</p>
<p>这里有一个小坑，所谓排序去重和去重排序在使用 <code>std::sort</code>
与 <code>std::unique</code> 来实现的时候是不一样的。由于
<code>std::unique</code>
只能把相邻的重复元素移动到容器末尾，所以要先排序再去重。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">X.<span class="built_in">resize</span>(<span class="number">2</span> * n + <span class="number">2</span>), Y.<span class="built_in">resize</span>(<span class="number">2</span> * n + <span class="number">2</span>), Z.<span class="built_in">resize</span>(<span class="number">2</span> * n + <span class="number">2</span>);</span><br><span class="line">X[<span class="number">2</span> * n] = Y[<span class="number">2</span> * n] = Z[<span class="number">2</span> * n] = <span class="number">0</span>;</span><br><span class="line">X[<span class="number">2</span> * n + <span class="number">1</span>] = Y[<span class="number">2</span> * n + <span class="number">1</span>] = Z[<span class="number">2</span> * n + <span class="number">1</span>] = MAXA;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">2</span>; j++) &#123;</span><br><span class="line">        cin &gt;&gt; B[i].x[j] &gt;&gt; B[i].y[j] &gt;&gt; B[i].z[j];</span><br><span class="line">        <span class="keyword">if</span> (j == <span class="number">1</span>) &#123;</span><br><span class="line">            B[i].x[<span class="number">1</span>] += B[i].x[<span class="number">0</span>];</span><br><span class="line">            B[i].y[<span class="number">1</span>] += B[i].y[<span class="number">0</span>];</span><br><span class="line">            B[i].z[<span class="number">1</span>] += B[i].z[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        X[<span class="number">2</span> * i + j] = B[i].x[j];</span><br><span class="line">        Y[<span class="number">2</span> * i + j] = B[i].y[j];</span><br><span class="line">        Z[<span class="number">2</span> * i + j] = B[i].z[j];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">sort</span>(<span class="built_in">all</span>(X)), X.<span class="built_in">erase</span>(<span class="built_in">unique</span>(<span class="built_in">all</span>(X)), X.<span class="built_in">end</span>());</span><br><span class="line"><span class="built_in">sort</span>(<span class="built_in">all</span>(Y)), Y.<span class="built_in">erase</span>(<span class="built_in">unique</span>(<span class="built_in">all</span>(Y)), Y.<span class="built_in">end</span>());</span><br><span class="line"><span class="built_in">sort</span>(<span class="built_in">all</span>(Z)), Z.<span class="built_in">erase</span>(<span class="built_in">unique</span>(<span class="built_in">all</span>(Z)), Z.<span class="built_in">end</span>());</span><br><span class="line">nx = X.<span class="built_in">size</span>(), ny = Y.<span class="built_in">size</span>(), nz = Z.<span class="built_in">size</span>();</span><br></pre></td></tr></table></figure>
<h3 id="离散化之后怎么求值">离散化之后怎么求值</h3>
<p>对于离散化之后坐标为 <span class="math inline">\(1\)</span>
的网格，我们需要知道它是空气还是立方体，还需要知道它所占的体积和与雕塑接触面的面积。</p>
<p>第一个需求我考虑使用 <code>tag[MAXN * 2][MAXN * 2][MAXN * 2]</code>
来标记，但是我只对坐标做了离散化，所以我需要保存每个立方体的信息，然后得到立方体在离散坐标系对应的新坐标，遍历这些坐标就可以了。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    <span class="type">int</span> x1 = <span class="built_in">lower_bound</span>(<span class="built_in">all</span>(X), B[i].x[<span class="number">0</span>]) - X.<span class="built_in">begin</span>();</span><br><span class="line">    <span class="type">int</span> x2 = <span class="built_in">lower_bound</span>(<span class="built_in">all</span>(X), B[i].x[<span class="number">1</span>]) - X.<span class="built_in">begin</span>();</span><br><span class="line">    <span class="type">int</span> y1 = <span class="built_in">lower_bound</span>(<span class="built_in">all</span>(Y), B[i].y[<span class="number">0</span>]) - Y.<span class="built_in">begin</span>();</span><br><span class="line">    <span class="type">int</span> y2 = <span class="built_in">lower_bound</span>(<span class="built_in">all</span>(Y), B[i].y[<span class="number">1</span>]) - Y.<span class="built_in">begin</span>();</span><br><span class="line">    <span class="type">int</span> z1 = <span class="built_in">lower_bound</span>(<span class="built_in">all</span>(Z), B[i].z[<span class="number">0</span>]) - Z.<span class="built_in">begin</span>();</span><br><span class="line">    <span class="type">int</span> z2 = <span class="built_in">lower_bound</span>(<span class="built_in">all</span>(Z), B[i].z[<span class="number">1</span>]) - Z.<span class="built_in">begin</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> x = x1; x &lt; x2; x++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> y = y1; y &lt; y2; y++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> z = z1; z &lt; z2; z++) tag[x][y][z] = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第二个需求，我们可以通过下标访问 <code>std::set&lt;int&gt;</code>
来获得一个格子的长宽高，体积就很容易了，至于求接触面我们需要遍历与它接触的
<span class="math inline">\(6\)</span> 个立方体判断是否属于雕塑。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">in_grid</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> z)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x &gt;= <span class="number">0</span> &amp;&amp; x &lt; nx - <span class="number">1</span> &amp;&amp; y &gt;= <span class="number">0</span> &amp;&amp; y &lt; ny - <span class="number">1</span> &amp;&amp; z &gt;= <span class="number">0</span> &amp;&amp; z &lt; nz - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">delta</span><span class="params">(<span class="type">int</span> x, <span class="type">const</span> vector&lt;<span class="type">int</span>&gt;&amp; X)</span> </span>&#123; <span class="keyword">return</span> X[x + <span class="number">1</span>] - X[x]; &#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">get_area</span><span class="params">(<span class="type">int</span> dx, <span class="type">int</span> dy, <span class="type">int</span> dz, <span class="type">int</span> dir)</span> </span>&#123;</span><br><span class="line">    dir /= <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (dir == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> dy * dz;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (dir == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> dx * dz;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> dx * dy;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bfs</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> z)</span> </span>&#123;</span><br><span class="line">    queue&lt;Point&gt; que;</span><br><span class="line">    tag[x][y][z] = <span class="number">2</span>;</span><br><span class="line">    que.<span class="built_in">push</span>(&#123;x, y, z&#125;);</span><br><span class="line">    <span class="keyword">while</span> (!que.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        Point f = que.<span class="built_in">front</span>();</span><br><span class="line">        que.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="type">int</span> dx = <span class="built_in">delta</span>(f.x, X), dy = <span class="built_in">delta</span>(f.y, Y), dz = <span class="built_in">delta</span>(f.z, Z);</span><br><span class="line">        v += dx * dy * dz;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> Point&amp; move : MOVES) &#123;</span><br><span class="line">            Point mv = f + move;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">in_grid</span>(mv.x, mv.y, mv.z) &amp;&amp; tag[mv.x][mv.y][mv.z] == <span class="number">1</span>)</span><br><span class="line">                s += <span class="built_in">get_area</span>(dx, dy, dz, &amp;move - MOVES);</span><br><span class="line">            <span class="keyword">if</span> (!<span class="built_in">in_grid</span>(mv.x, mv.y, mv.z) || tag[mv.x][mv.y][mv.z] != <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            tag[mv.x][mv.y][mv.z] = <span class="number">2</span>;</span><br><span class="line">            que.<span class="built_in">push</span>(mv);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="代码">代码</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> all(a) a.begin(), a.end()</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Box</span> &#123;</span><br><span class="line">    <span class="type">int</span> x[<span class="number">2</span>], y[<span class="number">2</span>], z[<span class="number">2</span>];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">    <span class="type">int</span> x, y, z;</span><br><span class="line">    Point <span class="keyword">operator</span>+(<span class="type">const</span> Point&amp; p) &#123; <span class="keyword">return</span> &#123;x + p.x, y + p.y, z + p.z&#125;; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">50</span> + <span class="number">2</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXA = <span class="number">1000</span> + <span class="number">2</span>;</span><br><span class="line"><span class="type">const</span> Point MOVES[] = &#123;&#123;<span class="number">-1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, <span class="number">-1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">-1</span>&#125;, &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>&#125;&#125;;</span><br><span class="line"><span class="type">int</span> n, v, s, nx, ny, nz;</span><br><span class="line"><span class="type">int</span> tag[MAXN * <span class="number">2</span>][MAXN * <span class="number">2</span>][MAXN * <span class="number">2</span>];</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; X, Y, Z;</span><br><span class="line">Box B[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">in_grid</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> z)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x &gt;= <span class="number">0</span> &amp;&amp; x &lt; nx - <span class="number">1</span> &amp;&amp; y &gt;= <span class="number">0</span> &amp;&amp; y &lt; ny - <span class="number">1</span> &amp;&amp; z &gt;= <span class="number">0</span> &amp;&amp; z &lt; nz - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">delta</span><span class="params">(<span class="type">int</span> x, <span class="type">const</span> vector&lt;<span class="type">int</span>&gt;&amp; X)</span> </span>&#123; <span class="keyword">return</span> X[x + <span class="number">1</span>] - X[x]; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">get_area</span><span class="params">(<span class="type">int</span> dx, <span class="type">int</span> dy, <span class="type">int</span> dz, <span class="type">int</span> dir)</span> </span>&#123;</span><br><span class="line">    dir /= <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (dir == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> dy * dz;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (dir == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> dx * dz;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> dx * dy;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bfs</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> z)</span> </span>&#123;</span><br><span class="line">    queue&lt;Point&gt; que;</span><br><span class="line">    tag[x][y][z] = <span class="number">2</span>;</span><br><span class="line">    que.<span class="built_in">push</span>(&#123;x, y, z&#125;);</span><br><span class="line">    <span class="keyword">while</span> (!que.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        Point f = que.<span class="built_in">front</span>();</span><br><span class="line">        que.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="type">int</span> dx = <span class="built_in">delta</span>(f.x, X), dy = <span class="built_in">delta</span>(f.y, Y), dz = <span class="built_in">delta</span>(f.z, Z);</span><br><span class="line">        v += dx * dy * dz;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> Point&amp; move : MOVES) &#123;</span><br><span class="line">            Point mv = f + move;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">in_grid</span>(mv.x, mv.y, mv.z) &amp;&amp; tag[mv.x][mv.y][mv.z] == <span class="number">1</span>)</span><br><span class="line">                s += <span class="built_in">get_area</span>(dx, dy, dz, &amp;move - MOVES);</span><br><span class="line">            <span class="keyword">if</span> (!<span class="built_in">in_grid</span>(mv.x, mv.y, mv.z) || tag[mv.x][mv.y][mv.z] != <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">            tag[mv.x][mv.y][mv.z] = <span class="number">2</span>;</span><br><span class="line">            que.<span class="built_in">push</span>(mv);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 预处理</span></span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    v = s = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">memset</span>(tag, <span class="number">0</span>, <span class="built_in">sizeof</span>(tag));</span><br><span class="line">    X.<span class="built_in">resize</span>(<span class="number">2</span> * n + <span class="number">2</span>), Y.<span class="built_in">resize</span>(<span class="number">2</span> * n + <span class="number">2</span>), Z.<span class="built_in">resize</span>(<span class="number">2</span> * n + <span class="number">2</span>);</span><br><span class="line">    X[<span class="number">2</span> * n] = Y[<span class="number">2</span> * n] = Z[<span class="number">2</span> * n] = <span class="number">0</span>;</span><br><span class="line">    X[<span class="number">2</span> * n + <span class="number">1</span>] = Y[<span class="number">2</span> * n + <span class="number">1</span>] = Z[<span class="number">2</span> * n + <span class="number">1</span>] = MAXA;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">2</span>; j++) &#123;</span><br><span class="line">            cin &gt;&gt; B[i].x[j] &gt;&gt; B[i].y[j] &gt;&gt; B[i].z[j];</span><br><span class="line">            <span class="keyword">if</span> (j == <span class="number">1</span>) &#123;</span><br><span class="line">                B[i].x[<span class="number">1</span>] += B[i].x[<span class="number">0</span>];</span><br><span class="line">                B[i].y[<span class="number">1</span>] += B[i].y[<span class="number">0</span>];</span><br><span class="line">                B[i].z[<span class="number">1</span>] += B[i].z[<span class="number">0</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            X[<span class="number">2</span> * i + j] = B[i].x[j];</span><br><span class="line">            Y[<span class="number">2</span> * i + j] = B[i].y[j];</span><br><span class="line">            Z[<span class="number">2</span> * i + j] = B[i].z[j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(<span class="built_in">all</span>(X)), X.<span class="built_in">erase</span>(<span class="built_in">unique</span>(<span class="built_in">all</span>(X)), X.<span class="built_in">end</span>());</span><br><span class="line">    <span class="built_in">sort</span>(<span class="built_in">all</span>(Y)), Y.<span class="built_in">erase</span>(<span class="built_in">unique</span>(<span class="built_in">all</span>(Y)), Y.<span class="built_in">end</span>());</span><br><span class="line">    <span class="built_in">sort</span>(<span class="built_in">all</span>(Z)), Z.<span class="built_in">erase</span>(<span class="built_in">unique</span>(<span class="built_in">all</span>(Z)), Z.<span class="built_in">end</span>());</span><br><span class="line">    nx = X.<span class="built_in">size</span>(), ny = Y.<span class="built_in">size</span>(), nz = Z.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 给离散网格打标记</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="type">int</span> x1 = <span class="built_in">lower_bound</span>(<span class="built_in">all</span>(X), B[i].x[<span class="number">0</span>]) - X.<span class="built_in">begin</span>();</span><br><span class="line">        <span class="type">int</span> x2 = <span class="built_in">lower_bound</span>(<span class="built_in">all</span>(X), B[i].x[<span class="number">1</span>]) - X.<span class="built_in">begin</span>();</span><br><span class="line">        <span class="type">int</span> y1 = <span class="built_in">lower_bound</span>(<span class="built_in">all</span>(Y), B[i].y[<span class="number">0</span>]) - Y.<span class="built_in">begin</span>();</span><br><span class="line">        <span class="type">int</span> y2 = <span class="built_in">lower_bound</span>(<span class="built_in">all</span>(Y), B[i].y[<span class="number">1</span>]) - Y.<span class="built_in">begin</span>();</span><br><span class="line">        <span class="type">int</span> z1 = <span class="built_in">lower_bound</span>(<span class="built_in">all</span>(Z), B[i].z[<span class="number">0</span>]) - Z.<span class="built_in">begin</span>();</span><br><span class="line">        <span class="type">int</span> z2 = <span class="built_in">lower_bound</span>(<span class="built_in">all</span>(Z), B[i].z[<span class="number">1</span>]) - Z.<span class="built_in">begin</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> x = x1; x &lt; x2; x++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> y = y1; y &lt; y2; y++)</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> z = z1; z &lt; z2; z++) tag[x][y][z] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// BFS 外部空气并求出体积面积</span></span><br><span class="line">    <span class="built_in">bfs</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出雕塑体积而非空气体积</span></span><br><span class="line">    cout &lt;&lt; s &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; MAXA * MAXA * MAXA - v &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    <span class="type">int</span> tt;</span><br><span class="line">    cin &gt;&gt; tt;</span><br><span class="line">    <span class="keyword">while</span> (tt--) <span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法竞赛</category>
        <category>题解</category>
      </categories>
      <tags>
        <tag>cpp</tag>
        <tag>AOAPC-II</tag>
      </tags>
  </entry>
  <entry>
    <title>UVA1643 题解</title>
    <url>/2024/10/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/%E9%A2%98%E8%A7%A3/AOAPC-II/Exercise-10-3/</url>
    <content><![CDATA[<p><a
href="https://onlinejudge.org/external/16/1643.pdf">英文题面</a></p>
<h2 id="题意">题意</h2>
<p>给定第一象限里的一个角与 <span class="math inline">\(n (n \le
10)\)</span>
个已知边长的正方形，把这些正方形摆放在这个角里面，使得它们与角形成的封闭图形面积尽可能大。</p>
<span id="more"></span>
<h2 id="纠正一下洛谷翻译的问题">纠正一下洛谷翻译的问题</h2>
<ol type="1">
<li><p>"正方形可以随意摆放，但必须与 <span
class="math inline">\(A\)</span>，<span class="math inline">\(B\)</span>
围成封闭图形。"
个人认为，正方形不可以随意摆放，四条边都需要和坐标轴平行，但是只需要与射线
<span class="math inline">\(OA\)</span>，<span
class="math inline">\(OB\)</span> 围成封闭图形。</p></li>
<li><p>关于数据范围，应当是 <span
class="math inline">\([1，20]\)</span>。</p></li>
</ol>
<h2 id="思路">思路</h2>
<p>第一篇题解已经给出思路了，正方形应当首尾相接，记这几个正方形与两个射线交于
<span class="math inline">\(A&#39;\)</span>，<span
class="math inline">\(B&#39;\)</span>，答案就是</p>
<p><span class="math display">\[S_{\triangle OA&#39;B&#39;} -
\sum_{i=1}^{n} \frac{l_i^2}{2}\]</span></p>
<p>至于怎么求出 <span class="math inline">\(A&#39;\)</span>，<span
class="math inline">\(B&#39;\)</span> 的坐标，我选择解方程组</p>
<p><span class="math display">\[
\begin{cases}
    \lambda x_A - \mu x_B = -\sum{}l_i \\[10pt]
    \lambda y_A - \mu y_B = \sum{}l_i
\end{cases}
\]</span></p>
<p>得到</p>
<p><span class="math display">\[
\begin{cases}
    \lambda = \dfrac{(x_B + y_B) \times \sum{}l_i}{x_B y_A - x_A y_B}
\\[10pt]
    \mu = \dfrac{(x_A + y_A) \times \sum{}l_i}{x_B y_A - x_A y_B}
\end{cases}
\]</span></p>
<p>我不确定是否需要注意几个正方形很小无法覆盖这个角的情况。</p>
<h2 id="代码">代码</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll = <span class="type">long</span> <span class="type">long</span>;  <span class="comment">// 2.15e9, 9.22e18</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">    <span class="type">double</span> x, y;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">scale</span><span class="params">(<span class="type">double</span> f)</span> </span>&#123; x *= f, y *= f; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">10</span> + <span class="number">3</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> EPS = <span class="number">1e-6</span>;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line">Point A, B;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">while</span> (cin &gt;&gt; n &amp;&amp; n) &#123;</span><br><span class="line">        cin &gt;&gt; A.x &gt;&gt; A.y &gt;&gt; B.x &gt;&gt; B.y;</span><br><span class="line">        <span class="type">double</span> ans = <span class="number">0</span>, sum_l = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="type">double</span> l;</span><br><span class="line">            cin &gt;&gt; l;</span><br><span class="line">            ans -= l / <span class="number">2</span> * l;</span><br><span class="line">            sum_l += l;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">double</span> temp = B.x * A.y - A.x * B.y;</span><br><span class="line">        <span class="type">double</span> lambda = (B.x + B.y) / temp * sum_l;</span><br><span class="line">        <span class="type">double</span> mu = (A.x + A.y) / temp * sum_l;</span><br><span class="line">        A.<span class="built_in">scale</span>(lambda), B.<span class="built_in">scale</span>(mu);</span><br><span class="line">        ans += <span class="built_in">abs</span>(A.x * B.y - B.x * A.y) / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">        cout &lt;&lt; fixed &lt;&lt; <span class="built_in">setprecision</span>(<span class="number">3</span>) &lt;&lt; ans + EPS &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法竞赛</category>
        <category>题解</category>
      </categories>
      <tags>
        <tag>cpp</tag>
        <tag>AOAPC-II</tag>
      </tags>
  </entry>
  <entry>
    <title>UVA509 题解</title>
    <url>/2024/10/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/%E9%A2%98%E8%A7%A3/AOAPC-II/Exercise-4-7/</url>
    <content><![CDATA[<p><a href="https://onlinejudge.org/external/5/509.pdf">英文题面</a></p>
<h2 id="题意">题意</h2>
<p>给出 <span class="math inline">\(d\)</span>
块磁盘的数据，每块磁盘的数据被分割为 <span
class="math inline">\(b\)</span> 块 <span
class="math inline">\(s\)</span> 个二进制数，其中 <span
class="math inline">\(x\)</span> 表示损坏的数据。</p>
<p>你的任务是判断这个磁盘阵列是否合法（数据无法恢复或奇偶校验错是非法的），如果合法，输出纠错后的内容（以十六进制输出）。需要注意如果数据长度不是
<span class="math inline">\(4\)</span> 的倍数，需要在数据末尾补 <span
class="math inline">\(0\)</span>。</p>
<span id="more"></span>
<h2 id="思路">思路</h2>
<p>题目要求以十六进制输出，但是每个数据块包含的比特数不是 <span
class="math inline">\(4\)</span>
的倍数，这样用整数表示数据不太合适，而且纠错的时候是每个二进制数独立操作的，为了写代码方便还是用字符串来保存数据吧。</p>
<p>对于判断磁盘阵列是否合法的方式，我们可以在读入数据的时候先把损坏数据视为
<span class="math inline">\(0\)</span>。遍历一块磁盘的 $ s b$
个二进制数，对于每个二进制数，我们再遍历每块磁盘，进行异或运算并数一下有几个损坏数据，如果损坏数据超过两个，那么很遗憾无法恢复了，如果损坏数据只有一个而且奇偶校验不对，那就说明我们之前把损坏数据视为
<span class="math inline">\(0\)</span> 是不对的，把它改为 <span
class="math inline">\(1\)</span>
就可以了（好像又有损坏又有数据错误这样恢复数据是错的?），如果没有损坏数据而且奇偶校验不对，那这个磁盘是非法的。</p>
<p>确定合法并恢复数据之后，我们就可以把数据全组合在一起每四位转换成一个十六进制数字输出了。</p>
<h2 id="代码">代码</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Disk</span> &#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; err;</span><br><span class="line">    string data;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123; err.<span class="built_in">clear</span>(), data.<span class="built_in">clear</span>(); &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">6</span> * <span class="number">64</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXD = <span class="number">6</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> d, s, b, parity, cur;</span><br><span class="line">string content;</span><br><span class="line">Disk D[MAXD];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将 content 中下标为区间 [l, l + 4) 的部分转换为十六进制</span></span><br><span class="line"><span class="function"><span class="type">char</span> <span class="title">conv</span><span class="params">(<span class="type">int</span> l)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> num = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">        num &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">        num += content[l + i] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (num &lt; <span class="number">10</span>)</span><br><span class="line">        <span class="keyword">return</span> num + <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> num - <span class="number">10</span> + <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> DEBUG</span></span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;/home/o06660o/Code/Cpp/test/main.in&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);</span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;/home/o06660o/Code/Cpp/test/main.out&quot;</span>, <span class="string">&quot;w&quot;</span>, stdout);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="type">int</span> kase = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (cin &gt;&gt; d &gt;&gt; s &gt;&gt; b &amp;&amp; d) &#123;</span><br><span class="line">        <span class="comment">// 处理输入</span></span><br><span class="line">        <span class="type">char</span> ch;</span><br><span class="line">        cin &gt;&gt; ch;</span><br><span class="line">        parity = (ch == <span class="string">&#x27;O&#x27;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; d; i++) &#123;</span><br><span class="line">            D[i].<span class="built_in">clear</span>();</span><br><span class="line">            string line;</span><br><span class="line">            cin &gt;&gt; line;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; line.<span class="built_in">length</span>(); j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (line[j] == <span class="string">&#x27;x&#x27;</span>) &#123;</span><br><span class="line">                    line[j] = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">                    D[i].err.<span class="built_in">push_back</span>(j);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            D[i].data = line;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 判断数据是否合法, 顺便恢复数据</span></span><br><span class="line">        <span class="type">bool</span> is_valid = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; s * b; i++) &#123;</span><br><span class="line">            <span class="type">int</span> check = <span class="number">0</span>, err_cnt = <span class="number">0</span>, err_p = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; d; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">find</span>(D[j].err.<span class="built_in">begin</span>(), D[j].err.<span class="built_in">end</span>(), i) != D[j].err.<span class="built_in">end</span>())</span><br><span class="line">                    err_cnt++, err_p = j;</span><br><span class="line">                check = check ^ (D[j].data[i] == <span class="string">&#x27;1&#x27;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (err_cnt &gt;= <span class="number">2</span> || (err_cnt == <span class="number">0</span> &amp;&amp; check != parity)) &#123;</span><br><span class="line">                is_valid = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">goto</span> output;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (err_cnt == <span class="number">1</span> &amp;&amp; check != parity) &#123;</span><br><span class="line">                D[err_p].data[i] = <span class="string">&#x27;1&#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果数据合法, 就把它们连接在一起, 接着转换为十六进制输出</span></span><br><span class="line">        content.<span class="built_in">clear</span>();</span><br><span class="line">        cur = <span class="number">-1</span>;  <span class="comment">// 当前第 cur 块磁盘存储校验数据</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; s * b; i += s) &#123;</span><br><span class="line">            cur = (cur + <span class="number">1</span>) % d;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; d; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (j == cur) <span class="keyword">continue</span>;</span><br><span class="line">                content += D[j].data.<span class="built_in">substr</span>(i, s);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (content.<span class="built_in">length</span>() % <span class="number">4</span> != <span class="number">0</span>) content += <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    output:</span><br><span class="line">        <span class="keyword">if</span> (!is_valid) &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;Disk set &quot;</span> &lt;&lt; kase++ &lt;&lt; <span class="string">&quot; is invalid.\n&quot;</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;Disk set &quot;</span> &lt;&lt; kase++ &lt;&lt; <span class="string">&quot; is valid, contents are: &quot;</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; content.<span class="built_in">length</span>(); i += <span class="number">4</span>) &#123;</span><br><span class="line">                cout &lt;&lt; <span class="built_in">conv</span>(i);</span><br><span class="line">            &#125;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法竞赛</category>
        <category>题解</category>
      </categories>
      <tags>
        <tag>cpp</tag>
        <tag>AOAPC-II</tag>
      </tags>
  </entry>
  <entry>
    <title>UVA1597 题解</title>
    <url>/2024/10/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/%E9%A2%98%E8%A7%A3/AOAPC-II/Exercise-5-10/</url>
    <content><![CDATA[<p><a
href="https://onlinejudge.org/external/15/1597.pdf">英文题面</a></p>
<h2 id="题意">题意</h2>
<p>输入 <span class="math inline">\(n (n &lt; 100)\)</span> 篇文章和
<span class="math inline">\(m (m \le 50000)\)</span>
个搜索请求，找到符合请求的文章并输出证据。</p>
<span id="more"></span>
<h2 id="思路">思路</h2>
<p>预处理文章中单词所对应的文章位置（使用
<code>std::pair&lt;int, int&gt;</code> 标记所在文章号与行号）。</p>
<p>查询语句一共有四种，好在我们可以找到一些共性。</p>
<p>比如 AND 和 OR 都是二元操作，可以把 term1 与 term2 的处理合并。而且
AND 的输出可以认为是加强后的 OR（就是把 OR
输出中不包含两个单词的文章舍弃）也可以合并。</p>
<p>另外四种语句的输出是一致的（NOT
需要输出全文可以认为是输出文章的每一行）。</p>
<h2 id="一些合并后的操作">一些合并后的操作</h2>
<h3 id="and-与-or-语句合并">AND 与 OR 语句合并</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">getline</span>(cin, line);</span><br><span class="line"><span class="function">istringstream <span class="title">iss</span><span class="params">(line)</span></span>;</span><br><span class="line">string term1, term2, op;</span><br><span class="line">set&lt;pii&gt; ans;</span><br><span class="line"><span class="keyword">if</span> (line.<span class="built_in">find</span>(<span class="string">&quot; AND &quot;</span>) != string::npos || line.<span class="built_in">find</span>(<span class="string">&quot; OR &quot;</span>) != string::npos) &#123;</span><br><span class="line">    iss &gt;&gt; term1 &gt;&gt; op &gt;&gt; term2;</span><br><span class="line">    <span class="built_in">insert</span>(ans, term1, <span class="number">0</span>), <span class="built_in">insert</span>(ans, term2, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (op[<span class="number">0</span>] == <span class="string">&#x27;A&#x27;</span>) &#123;</span><br><span class="line">        set&lt;pii&gt; cp = ans;</span><br><span class="line">        ans.<span class="built_in">clear</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cnt[i] == <span class="number">2</span>)</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">const</span> pii&amp; p : cp)</span><br><span class="line">                    <span class="keyword">if</span> (p.first == i) ans.<span class="built_in">insert</span>(p);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>其中抽象出来了一个函数 <code>insert()</code>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 将出现单词 term 的位置插入 ans, tag 是用来正确更新 cnt 的</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(set&lt;pii&gt;&amp; ans, <span class="type">const</span> string&amp; term, <span class="type">int</span> tag)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> f = M.<span class="built_in">find</span>(term);</span><br><span class="line">    <span class="keyword">if</span> (f != M.<span class="built_in">end</span>()) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> pii&amp; p : f-&gt;second) &#123;</span><br><span class="line">            ans.<span class="built_in">insert</span>(p);</span><br><span class="line">            <span class="keyword">if</span> (cnt[p.first] == tag) cnt[p.first]++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="输出合并">输出合并</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">const</span> set&lt;pii&gt;&amp; ans)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (ans.<span class="built_in">empty</span>()) cout &lt;&lt; <span class="string">&quot;Sorry, I found nothing.\n&quot;</span>;</span><br><span class="line">    <span class="type">int</span> pre = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> pii&amp; p : ans) &#123;</span><br><span class="line">        <span class="keyword">if</span> (pre == <span class="number">-1</span>) &#123;</span><br><span class="line">            pre = p.first;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pre != p.first) &#123;</span><br><span class="line">            pre = p.first;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;----------\n&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; doc[p.first][p.second] &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="代码">代码</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> pii = pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">100</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> cnt[MAXN];</span><br><span class="line">vector&lt;string&gt; doc[MAXN];</span><br><span class="line">map&lt;string, set&lt;pii&gt; &gt; M;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 预处理第 i 段文字的第 j 行</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">parse</span><span class="params">(string line, <span class="type">int</span> i, <span class="type">int</span> j)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; (<span class="type">int</span>)line.<span class="built_in">size</span>(); i++)</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">isalpha</span>(line[i]))</span><br><span class="line">            line[i] = <span class="built_in">tolower</span>(line[i]);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            line[i] = <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    <span class="function">istringstream <span class="title">iss</span><span class="params">(line)</span></span>;</span><br><span class="line">    string word;</span><br><span class="line">    <span class="keyword">while</span> (iss &gt;&gt; word) &#123;</span><br><span class="line">        pii temp = &#123;i, j&#125;;</span><br><span class="line">        <span class="keyword">if</span> (M.<span class="built_in">count</span>(word)) &#123;</span><br><span class="line">            <span class="comment">// 一行文字可能有多个相同单词</span></span><br><span class="line">            <span class="keyword">if</span> (*M[word].<span class="built_in">rbegin</span>() != temp) M[word].<span class="built_in">insert</span>(temp);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            M[word].<span class="built_in">insert</span>(temp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将出现单词 term 的位置插入 ans, tag 是用来正确更新 cnt 的</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(set&lt;pii&gt;&amp; ans, <span class="type">const</span> string&amp; term, <span class="type">int</span> tag)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> f = M.<span class="built_in">find</span>(term);</span><br><span class="line">    <span class="keyword">if</span> (f != M.<span class="built_in">end</span>()) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> pii&amp; p : f-&gt;second) &#123;</span><br><span class="line">            ans.<span class="built_in">insert</span>(p);</span><br><span class="line">            <span class="keyword">if</span> (cnt[p.first] == tag) cnt[p.first]++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">const</span> set&lt;pii&gt;&amp; ans)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (ans.<span class="built_in">empty</span>()) cout &lt;&lt; <span class="string">&quot;Sorry, I found nothing.\n&quot;</span>;</span><br><span class="line">    <span class="type">int</span> pre = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> pii&amp; p : ans) &#123;</span><br><span class="line">        <span class="keyword">if</span> (pre == <span class="number">-1</span>) &#123;</span><br><span class="line">            pre = p.first;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pre != p.first) &#123;</span><br><span class="line">            pre = p.first;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;----------\n&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; doc[p.first][p.second] &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    cin.<span class="built_in">ignore</span>();</span><br><span class="line">    string line;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>; i &lt; n; i++, j = <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">getline</span>(cin, line) &amp;&amp; line != <span class="string">&quot;**********&quot;</span>) &#123;</span><br><span class="line">            <span class="built_in">parse</span>(line, i, j++);</span><br><span class="line">            doc[i].<span class="built_in">push_back</span>(line);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cin &gt;&gt; m;</span><br><span class="line">    cin.<span class="built_in">ignore</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">        <span class="built_in">memset</span>(cnt, <span class="number">0</span>, <span class="built_in">sizeof</span>(cnt));</span><br><span class="line">        <span class="built_in">getline</span>(cin, line);</span><br><span class="line">        <span class="function">istringstream <span class="title">iss</span><span class="params">(line)</span></span>;</span><br><span class="line">        string term1, term2, op;</span><br><span class="line">        set&lt;pii&gt; ans;</span><br><span class="line">        <span class="keyword">if</span> (line.<span class="built_in">find</span>(<span class="string">&quot; AND &quot;</span>) != string::npos ||</span><br><span class="line">            line.<span class="built_in">find</span>(<span class="string">&quot; OR &quot;</span>) != string::npos) &#123;</span><br><span class="line">            iss &gt;&gt; term1 &gt;&gt; op &gt;&gt; term2;</span><br><span class="line">            <span class="built_in">insert</span>(ans, term1, <span class="number">0</span>), <span class="built_in">insert</span>(ans, term2, <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (op[<span class="number">0</span>] == <span class="string">&#x27;A&#x27;</span>) &#123;</span><br><span class="line">                set&lt;pii&gt; cp = ans;</span><br><span class="line">                ans.<span class="built_in">clear</span>();</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (cnt[i] == <span class="number">2</span>)</span><br><span class="line">                        <span class="keyword">for</span> (<span class="type">const</span> pii&amp; p : cp)</span><br><span class="line">                            <span class="keyword">if</span> (p.first == i) ans.<span class="built_in">insert</span>(p);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (line.<span class="built_in">find</span>(<span class="string">&quot;NOT &quot;</span>) != string::npos) &#123;</span><br><span class="line">            iss &gt;&gt; op &gt;&gt; term1;</span><br><span class="line">            <span class="keyword">auto</span> f = M.<span class="built_in">find</span>(term1);</span><br><span class="line">            <span class="keyword">if</span> (f != M.<span class="built_in">end</span>())</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">const</span> pii&amp; p : f-&gt;second) cnt[p.first] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">                <span class="keyword">if</span> (!cnt[i])</span><br><span class="line">                    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; (<span class="type">int</span>)doc[i].<span class="built_in">size</span>(); j++)</span><br><span class="line">                        ans.<span class="built_in">insert</span>(&#123;i, j&#125;);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">insert</span>(ans, line, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">print</span>(ans);</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;==========\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法竞赛</category>
        <category>题解</category>
      </categories>
      <tags>
        <tag>cpp</tag>
        <tag>AOAPC-II</tag>
      </tags>
  </entry>
  <entry>
    <title>UVA12504 题解</title>
    <url>/2024/10/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/%E9%A2%98%E8%A7%A3/AOAPC-II/Exercise-5-11/</url>
    <content><![CDATA[<p><a
href="https://onlinejudge.org/external/125/12504.pdf">英文题面</a></p>
<p>突然发现 C++ 标准库好强大。顺便介绍一下 <code>regex</code> 库。</p>
<h2 id="题意">题意</h2>
<p>输入一个旧字典和新字典，输出字典的变化。</p>
<span id="more"></span>
<h2 id="思路">思路</h2>
<p>首先注意本题有多组数据，每组输出数据后要空一行。</p>
<p>然后是处理输入数据，本题的输入以字典形式给出，提取 <code>key</code>
与 <code>value</code> 的过程我们使用正则。</p>
<p>处理完输入数据就简单了，暴力遍历其中一个字典，分析每一个元素在另外一个字典是否存在，如果存在比较是否有变化，不存在就是增加/删除的元素。</p>
<p>虽然是朴素的暴力，但写代码的时候一些重复部分可以优化。</p>
<p>比如确定字典元素的增加与删除，其实就是把旧字典和新字典地位互换。还有就是数据的输入，增删改只有第一个字符
<code>+-*</code> 不一样。</p>
<h2 id="对于正则表达式的简单介绍">对于正则表达式的简单介绍</h2>
<h3 id="基础语法">基础语法</h3>
<h4 id="基础符号">基础符号</h4>
<ul>
<li><code>.</code> 匹配除了换行符的任何单个字符</li>
<li><code>^</code> 匹配字符串开始</li>
<li><code>$</code> 匹配字符串结束</li>
</ul>
<h4 id="量词">量词</h4>
<ul>
<li><code>+</code> 匹配前面字符一次或多次</li>
<li><code>*</code> 匹配前面字符零次或多次</li>
<li><code>?</code> 匹配前面字符零次或一次</li>
<li><code>&#123;n&#125;</code> 匹配前面字符恰好 <code>n</code> 次</li>
<li><code>&#123;n,m&#125;</code> 匹配前面字符闭区间 <code>[n, m]</code> 次</li>
</ul>
<p>例如 <code>a+, b&#123;3&#125;</code> 分别匹配 <code>a</code> 一次或多次， 匹配
<code>b</code> 恰好 3 次。</p>
<h4 id="预定义字符">预定义字符</h4>
<ul>
<li><code>\d</code> 数字</li>
<li><code>\D</code> 非数字</li>
<li><code>\w</code> 字母数字下划线</li>
<li><code>\W</code> 非 <code>\w</code></li>
<li><code>\s</code> 空格制表符换行符</li>
<li><code>\S</code> 非 <code>\s</code></li>
</ul>
<h4 id="组合">组合</h4>
<ul>
<li><code>[aeiou]</code> 匹配一个元音字符</li>
<li><code>[^abc]</code> 匹配除了 <code>abc</code> 的字符</li>
<li><code>[a-z]</code> 匹配小写字母</li>
<li><code>(abc)+</code> 匹配一个或多个 <code>abc</code></li>
<li><code>a|b</code> 匹配 <code>a</code> 或者 <code>b</code></li>
</ul>
<h3 id="类">类</h3>
<ul>
<li><code>regex</code> 用于存储编译后的正则表达式</li>
<li><code>smatch</code> 用于存储字符串匹配的结果, <code>cmatch</code>
类似于 <code>smatch</code>, 但用于 C 风格字符数组</li>
<li><code>regex_iterator</code> 用于遍历所有匹配的子串, 支持泛型</li>
<li><code>sregex_iterator</code> 用于遍历所有匹配的子串, 用法如下
<code>for (sregex_iterator it(all(buf), pattern); it != sregex_iterator(); it++)</code></li>
<li><code>regex_token_iterator</code> 用于根据正则表达式分割字符串</li>
</ul>
<h3 id="函数">函数</h3>
<h4 id="regex_search">regex_search()</h4>
<p><code>bool regex_search(const string&amp; s, const regex&amp; pattern)</code>
<code>bool regex_search(const string&amp; s, smatch&amp; match, const regex&amp; pattern)</code>
查找字符串中是否有与正则表达式匹配的部分, 并将结果存储在
<code>smatch</code> 中. 用于子串查找; 正则表达式中用 <code>()</code>
括起来的部分会被捕获存在 <code>smatch</code> 中.</p>
<h4 id="regex_match">regex_match()</h4>
<p><code>bool regex_match(const string&amp; s, smatch&amp; match, const regex&amp; re)</code>
检查整个字符串是否完全匹配正则表达式.</p>
<h4 id="regex_replace">regex_replace()</h4>
<p><code>string regex_replace(const string&amp; s, const regex&amp; re, const string&amp; format)</code>
用指定的替换字符串替换正则表达式匹配的部分.</p>
<h3 id="在本题中的应用">在本题中的应用</h3>
<p><code>const regex pattern(R"((\w+):(\d+))");</code>
初始化正则表达式，</p>
<p>通过
<code>for (sregex_iterator it(all(buf), pattern); it != sregex_iterator(); it++)</code>
来遍历每一个匹配的元素，</p>
<p><code>(*it)[1]]</code> 是键，<code>(*it)[2]]</code> 是值。</p>
<h2 id="代码">代码</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> all(a) a.begin(), a.end()</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">const</span> regex <span class="title">pattern</span><span class="params">(<span class="string">R&quot;((\w+):(\d+))&quot;</span>)</span></span>;</span><br><span class="line">map&lt;string, string&gt; M1, M2;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">parse</span><span class="params">(map&lt;string, string&gt;&amp; M)</span> </span>&#123;</span><br><span class="line">    string buf;</span><br><span class="line">    cin &gt;&gt; buf;</span><br><span class="line">    <span class="keyword">for</span> (sregex_iterator <span class="built_in">it</span>(<span class="built_in">all</span>(buf), pattern); it != <span class="built_in">sregex_iterator</span>(); it++)</span><br><span class="line">        M[(*it)[<span class="number">1</span>]] = (*it)[<span class="number">2</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">vector&lt;string&gt; <span class="title">solve_add_key</span><span class="params">(map&lt;string, string&gt;&amp; M1, map&lt;string, string&gt;&amp; M2)</span> </span>&#123;</span><br><span class="line">    vector&lt;string&gt; ans;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; item : M2)</span><br><span class="line">        <span class="keyword">if</span> (!M<span class="number">1.</span><span class="built_in">count</span>(item.first)) ans.<span class="built_in">push_back</span>(item.first);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">const</span> vector&lt;string&gt;&amp; ans, <span class="type">char</span> ch)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (ans.<span class="built_in">empty</span>()) <span class="keyword">return</span>;</span><br><span class="line">    cout &lt;&lt; ch;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> it = ans.<span class="built_in">begin</span>(); it != ans.<span class="built_in">end</span>();)</span><br><span class="line">        cout &lt;&lt; *it &lt;&lt; <span class="string">&quot;,\n&quot;</span>[++it == ans.<span class="built_in">end</span>()];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    M<span class="number">1.</span><span class="built_in">clear</span>(), M<span class="number">2.</span><span class="built_in">clear</span>();</span><br><span class="line">    <span class="built_in">parse</span>(M1), <span class="built_in">parse</span>(M2);</span><br><span class="line">    vector&lt;string&gt; ans[<span class="number">3</span>];</span><br><span class="line">    ans[<span class="number">0</span>] = <span class="built_in">solve_add_key</span>(M1, M2), ans[<span class="number">1</span>] = <span class="built_in">solve_add_key</span>(M2, M1);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; item : M2)</span><br><span class="line">        <span class="keyword">if</span> (M<span class="number">1.</span><span class="built_in">count</span>(item.first) &amp;&amp; M1[item.first] != item.second)</span><br><span class="line">            ans[<span class="number">2</span>].<span class="built_in">push_back</span>(item.first);</span><br><span class="line">    <span class="built_in">print</span>(ans[<span class="number">0</span>], <span class="string">&#x27;+&#x27;</span>), <span class="built_in">print</span>(ans[<span class="number">1</span>], <span class="string">&#x27;-&#x27;</span>), <span class="built_in">print</span>(ans[<span class="number">2</span>], <span class="string">&#x27;*&#x27;</span>);</span><br><span class="line">    <span class="keyword">if</span> (ans[<span class="number">0</span>].<span class="built_in">empty</span>() &amp;&amp; ans[<span class="number">1</span>].<span class="built_in">empty</span>() &amp;&amp; ans[<span class="number">2</span>].<span class="built_in">empty</span>())</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;No changes\n&quot;</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    <span class="type">int</span> tt;</span><br><span class="line">    cin &gt;&gt; tt;</span><br><span class="line">    <span class="keyword">while</span> (tt--) <span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法竞赛</category>
        <category>题解</category>
      </categories>
      <tags>
        <tag>cpp</tag>
        <tag>AOAPC-II</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeforces Round 966 (Div. 3) G 题解</title>
    <url>/2024/10/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/%E9%A2%98%E8%A7%A3/Codeforces/CF2000G/</url>
    <content><![CDATA[<p><a
href="https://codeforces.com/contest/2000/problem/G">英文题面</a></p>
<h2 id="题意">题意</h2>
<p>给出一个 <span class="math inline">\(n\)</span> 个点 <span
class="math inline">\(m\)</span> 条边的简单图，每条边 <span
class="math inline">\(i\)</span> 有用时分别为 <span
class="math inline">\((l_{i1} &lt; l_{i2})\)</span> 的两种线路，若在
<span class="math inline">\([t1，t2]\)</span>
时间内经过只能选择用时更长的线路。需要求出从节点 <span
class="math inline">\(1\)</span> 出发，在 <span
class="math inline">\(t_0\)</span> 之前到达节点 <span
class="math inline">\(n\)</span> 的最晚出发时间，若无法成功达到节点
<span class="math inline">\(n\)</span> 输出 <span
class="math inline">\(-1\)</span>。</p>
<p>数据范围:</p>
<ul>
<li><span class="math inline">\(2 \le n \le 10^5\)</span>；</li>
<li><span class="math inline">\(1 \le m \le 10^5\)</span>；</li>
<li><span class="math inline">\(1 \le t1 &lt; t2 &lt; t0 \le
10^9\)</span>。</li>
</ul>
<span id="more"></span>
<h2 id="思路">思路</h2>
<p>需要求出最晚出发时间，而它对应的到达时间固定为 <span
class="math inline">\(t_0\)</span>，我们可以考虑把节点 <span
class="math inline">\(n\)</span> 作为起点，定义 <span
class="math inline">\(d[i]\)</span> 为从节点 <span
class="math inline">\(i\)</span> 出发，刚好在时间 <span
class="math inline">\(t_0\)</span> 到达节点 <span
class="math inline">\(n\)</span> 的最晚出发时间。使用 Dijkstra 算法进行
<span class="math inline">\(n\)</span> 次松弛操作即可。</p>
<p>更具体的说，维护一个优先队列，包含未确定最短路的节点 <span
class="math inline">\(i\)</span> 与它可以到达节点 <span
class="math inline">\(n\)</span>
的出发时间。每次选择出发时间最晚的元素出队，并把与它相邻的节点到达节点
<span class="math inline">\(n\)</span>
的其他可能出发时间插入优先队列。</p>
<p>而要求出节点 <span class="math inline">\(u\)</span> 的相邻节点 <span
class="math inline">\(v\)</span> 到达节点 <span
class="math inline">\(n\)</span>
的可能出发时间，要根据经过这条边的时间是否与 <span
class="math inline">\([t1, t2]\)</span>
有交集分类讨论。如果没有交集，直接选择 <span
class="math inline">\(l_{u1}\)</span> 即可；如果有交集，需要考虑选择
<span class="math inline">\(l_{u2}\)</span> 和等待到 <span
class="math inline">\(t1\)</span> 时刻再选择 <span
class="math inline">\(l_{u1}\)</span> 两种情况。</p>
<h2 id="代码">代码</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> all(a) a.begin(), a.end()</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll = <span class="type">long</span> <span class="type">long</span>;  <span class="comment">// 2.15e9, 9.22e18</span></span><br><span class="line"><span class="keyword">using</span> pii = pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span> &#123;</span><br><span class="line">    <span class="type">int</span> to, w1, w2;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">1e9</span>;</span><br><span class="line"><span class="type">int</span> n, m, t0, t1, t2;</span><br><span class="line"><span class="type">int</span> d[MAXN];</span><br><span class="line">vector&lt;Edge&gt; G[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m &gt;&gt; t0 &gt;&gt; t1 &gt;&gt; t2;</span><br><span class="line">    <span class="built_in">fill</span>(d, d + n + <span class="number">1</span>, -INF);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) G[i].<span class="built_in">clear</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">        <span class="type">int</span> u, v, w1, w2;</span><br><span class="line">        cin &gt;&gt; u &gt;&gt; v &gt;&gt; w1 &gt;&gt; w2;</span><br><span class="line">        G[u].<span class="built_in">push_back</span>(&#123;v, w1, w2&#125;), G[v].<span class="built_in">push_back</span>(&#123;u, w1, w2&#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    priority_queue&lt;pii&gt; pq;</span><br><span class="line">    pq.<span class="built_in">push</span>(&#123;t0, n&#125;);</span><br><span class="line">    d[n] = t0;</span><br><span class="line">    <span class="keyword">while</span> (!pq.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        pii p = pq.<span class="built_in">top</span>();</span><br><span class="line">        pq.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span> (d[p.second] != p.first) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; e : G[p.second]) &#123;</span><br><span class="line">            <span class="type">int</span> tmp;</span><br><span class="line">            <span class="keyword">if</span> (p.first - e.w1 &gt;= t2 || p.first &lt;= t1) &#123;</span><br><span class="line">                tmp = p.first - e.w1;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                tmp = <span class="built_in">max</span>(p.first - e.w2, t1 - e.w1);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (d[e.to] &lt; tmp) &#123;</span><br><span class="line">                d[e.to] = tmp;</span><br><span class="line">                pq.<span class="built_in">push</span>(&#123;d[e.to], e.to&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; (d[<span class="number">1</span>] &gt;= <span class="number">0</span> ? d[<span class="number">1</span>] : <span class="number">-1</span>) &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    <span class="type">int</span> tt;</span><br><span class="line">    cin &gt;&gt; tt;</span><br><span class="line">    <span class="keyword">while</span> (tt--) <span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法竞赛， 题解</category>
      </categories>
      <tags>
        <tag>cpp</tag>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title>线段树模板</title>
    <url>/2024/11/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/%E6%A8%A1%E6%9D%BF/SegmentTree/</url>
    <content><![CDATA[<p>简单的线段树模板, 支持区间修改与查询.</p>
<span id="more"></span>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">SegmentTree</span> &#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">        <span class="type">int</span> sum, tag;</span><br><span class="line">        <span class="built_in">Node</span>() : <span class="built_in">sum</span>(<span class="number">0</span>), <span class="built_in">tag</span>(<span class="number">0</span>) &#123;&#125;</span><br><span class="line">        Node <span class="keyword">operator</span>+(<span class="type">const</span> Node&amp; v) <span class="type">const</span> &#123;</span><br><span class="line">            Node ret = <span class="built_in">Node</span>();</span><br><span class="line">            ret.sum = sum + v.sum;</span><br><span class="line">            <span class="keyword">return</span> ret;</span><br><span class="line">        &#125;</span><br><span class="line">        Node&amp; <span class="keyword">operator</span>+=(<span class="type">const</span> Node&amp; v) &#123; <span class="keyword">return</span> *<span class="keyword">this</span> = *<span class="keyword">this</span> + v; &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="type">int</span> n, l, r, k;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; a;</span><br><span class="line">    vector&lt;Node&gt; tree;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> pl, <span class="type">int</span> pr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (pr - pl == <span class="number">1</span>) &#123;</span><br><span class="line">            tree[p].sum = a[pl];</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> lc = p &lt;&lt; <span class="number">1</span>, rc = p &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid = pl + (pr - pl) / <span class="number">2</span>;</span><br><span class="line">        <span class="built_in">build</span>(lc, pl, mid), <span class="built_in">build</span>(rc, mid, pr);</span><br><span class="line">        tree[p] = tree[lc] + tree[rc];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">(<span class="type">int</span> N)</span> </span>&#123;</span><br><span class="line">        n = N;</span><br><span class="line">        a.<span class="built_in">resize</span>(n + <span class="number">5</span>);</span><br><span class="line">        tree.<span class="built_in">resize</span>(n * <span class="number">4</span> + <span class="number">5</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) cin &gt;&gt; a[i];</span><br><span class="line">        <span class="built_in">build</span>(<span class="number">1</span>, <span class="number">0</span>, n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">SegmentTree</span>(<span class="type">int</span> N) &#123; <span class="built_in">init</span>(N); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push_down</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> pl, <span class="type">int</span> pr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (tree[p].tag == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="type">int</span> lc = p &lt;&lt; <span class="number">1</span>, rc = p &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid = pl + (pr - pl) / <span class="number">2</span>;</span><br><span class="line">        tree[lc].sum += (mid - pl) * tree[p].tag;</span><br><span class="line">        tree[rc].sum += (pr - mid) * tree[p].tag;</span><br><span class="line">        tree[lc].tag += tree[p].tag;</span><br><span class="line">        tree[rc].tag += tree[p].tag;</span><br><span class="line">        tree[p].tag = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">Node <span class="title">query</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> pl, <span class="type">int</span> pr)</span> </span>&#123;</span><br><span class="line">        Node ret;</span><br><span class="line">        <span class="keyword">if</span> (l &lt;= pl &amp;&amp; pr &lt;= r) &#123;</span><br><span class="line">            ret = tree[p];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">int</span> lc = p &lt;&lt; <span class="number">1</span>, rc = p &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid = pl + (pr - pl) / <span class="number">2</span>;</span><br><span class="line">            <span class="built_in">push_down</span>(p, pl, pr);</span><br><span class="line">            <span class="keyword">if</span> (l &lt; mid) ret += <span class="built_in">query</span>(lc, pl, mid);</span><br><span class="line">            <span class="keyword">if</span> (r &gt; mid) ret += <span class="built_in">query</span>(rc, mid, pr);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">Node <span class="title">query</span><span class="params">(<span class="type">int</span> L, <span class="type">int</span> R)</span> </span>&#123;</span><br><span class="line">        l = L, r = R;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">query</span>(<span class="number">1</span>, <span class="number">0</span>, n);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> pl, <span class="type">int</span> pr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l &lt;= pl &amp;&amp; pr &lt;= r) &#123;</span><br><span class="line">            tree[p].sum += (pr - pl) * k;</span><br><span class="line">            tree[p].tag += k;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">int</span> lc = p &lt;&lt; <span class="number">1</span>, rc = p &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid = pl + (pr - pl) / <span class="number">2</span>;</span><br><span class="line">            <span class="built_in">push_down</span>(p, pl, pr);</span><br><span class="line">            <span class="keyword">if</span> (l &lt; mid) <span class="built_in">update</span>(lc, pl, mid);</span><br><span class="line">            <span class="keyword">if</span> (r &gt; mid) <span class="built_in">update</span>(rc, mid, pr);</span><br><span class="line">            tree[p] = tree[lc] + tree[rc];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> L, <span class="type">int</span> R, ll K)</span> </span>&#123;</span><br><span class="line">        l = L, r = R, k = K;</span><br><span class="line">        <span class="built_in">update</span>(<span class="number">1</span>, <span class="number">0</span>, n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法竞赛</category>
        <category>模板</category>
      </categories>
      <tags>
        <tag>cpp</tag>
      </tags>
  </entry>
  <entry>
    <title>IO 优化</title>
    <url>/2024/10/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/IO/</url>
    <content><![CDATA[<p>水群看到群友说 <code>gechar()</code> 是慢读,
研究了一下发现确实有优化空间.</p>
<p>下面我以 <a href="https://loj.ac/p/7">LibreOJ #7. Input Test</a>
为例进行了几个测试.</p>
<span id="more"></span>
<h2 id="cin">cin</h2>
<p><code>cin</code> 有两个地方可以优化, 分别是
<code>ios::sync_with_stdio(false)</code> 与
<code>cin.tie(nullptr)</code>. 事实上, 这两步优化可以简写为
<code>cin.tie(nullptr)-&gt;ios::sync_with_stdio(false)</code>.</p>
<p>在 <code>main()</code> 里面加上一行优化代码后面正常使用
<code>cin</code> 就行了. 不过需要注意 <code>cin</code> 与
<code>scanf()</code> 不可以混用, <code>cout</code> 与
<code>printf()</code> 也不可以混用. 好在 <code>cin</code> 与
<code>printf()</code>, <code>cout</code> 与 <code>scanf()</code>
还是可以的.</p>
<h2 id="getchar">getchar()</h2>
<p>代码如下</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">ll <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ll x = <span class="number">0</span>, f = <span class="number">1</span>;</span><br><span class="line">    <span class="type">char</span> ch = <span class="built_in">getchar_unlocked</span>();</span><br><span class="line">    <span class="keyword">while</span> (ch &lt; <span class="string">&#x27;0&#x27;</span> || ch &gt; <span class="string">&#x27;9&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ch == <span class="string">&#x27;-&#x27;</span>) f = <span class="number">-1</span>;</span><br><span class="line">        ch = <span class="built_in">getchar_unlocked</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (ch &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; ch &lt;= <span class="string">&#x27;9&#x27;</span>)</span><br><span class="line">        x = (x &lt;&lt; <span class="number">3</span>) + (x &lt;&lt; <span class="number">1</span>) + (ch ^ <span class="number">48</span>), ch = <span class="built_in">getchar_unlocked</span>();</span><br><span class="line">    <span class="keyword">return</span> x * f;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果使用 <code>read()</code> 最好不要采用其他数据输入方式.</p>
<h2 id="getchar_unlocked">getchar_unlocked()</h2>
<p>代码就是上面的 <code>getchar()</code> 替换成
<code>getchar_unlocked()</code>.</p>
<p>至于这两个函数的区别大概有两点:</p>
<ol type="1">
<li>后者并非线程安全, 只适合在单线程环境下使用;</li>
<li>后者并非标准函数, 在 Windows 系统下可能 CE (好像可以选择用
<code>_getchar_nolock()</code> 来替代).</li>
</ol>
<h2 id="fread">fread()</h2>
<p>代码如下</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> BUFSIZE = <span class="number">1</span> &lt;&lt; <span class="number">20</span>;</span><br><span class="line"><span class="type">char</span> ibuf[BUFSIZE], *is = ibuf, *it = ibuf;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">char</span> <span class="title">getch</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (is == it) it = (is = ibuf) + <span class="built_in">fread</span>(ibuf, <span class="number">1</span>, BUFSIZE, stdin);</span><br><span class="line">    <span class="keyword">return</span> is == it ? EOF : *is++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ll x = <span class="number">0</span>, f = <span class="number">1</span>;</span><br><span class="line">    <span class="type">char</span> ch = <span class="built_in">getch</span>();</span><br><span class="line">    <span class="keyword">while</span> (ch &lt; <span class="string">&#x27;0&#x27;</span> || ch &gt; <span class="string">&#x27;9&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ch == <span class="string">&#x27;-&#x27;</span>) f = <span class="number">-1</span>;</span><br><span class="line">        ch = <span class="built_in">getch</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (ch &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; ch &lt;= <span class="string">&#x27;9&#x27;</span>)</span><br><span class="line">        x = (x &lt;&lt; <span class="number">3</span>) + (x &lt;&lt; <span class="number">1</span>) + (ch ^ <span class="number">48</span>), ch = <span class="built_in">getch</span>();</span><br><span class="line">    <span class="keyword">return</span> x * f;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>fread()</code> 好像也有对应的 <code>fread_unlocked()</code>,
但是效率提升不明显 (?).</p>
<h2 id="测试结果">测试结果</h2>
<ul>
<li>无优化 <code>cin</code>: 4290 ms;</li>
<li>关同步 <code>cin</code>: 857 ms;</li>
<li>关同步 + 解绑定 <code>cin</code>: 765 ms;</li>
<li><code>getchar()</code> 快读: 513 ms;</li>
<li><code>getchar_unlocked()</code> 快读: 195 ms;</li>
<li><code>fread()</code> 替代 <code>getchar()</code> 快读: 179 ms;</li>
<li><code>fread_unlocked()</code> 替代 <code>getchar()</code> 快读: 179
ms.</li>
</ul>
]]></content>
      <categories>
        <category>算法竞赛</category>
      </categories>
      <tags>
        <tag>cpp</tag>
      </tags>
  </entry>
  <entry>
    <title>vimrc</title>
    <url>/2024/10/%E6%9D%82%E9%A1%B9/vimrc/</url>
    <content><![CDATA[<p>算法竞赛中为了快速配置 vim 需要一个简短的 <code>.vimrc</code>
模板.</p>
<span id="more"></span>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">color slate</span><br><span class="line"><span class="keyword">syntax</span> <span class="keyword">on</span></span><br><span class="line"><span class="keyword">set</span> rnu hls cin et <span class="keyword">ts</span>=<span class="number">4</span> <span class="keyword">sw</span>=<span class="number">4</span> <span class="keyword">so</span>=<span class="number">8</span> mouse=<span class="keyword">a</span> nocompatible</span><br><span class="line"><span class="keyword">filetype</span> plugin <span class="built_in">indent</span> <span class="keyword">on</span></span><br><span class="line"><span class="keyword">nnoremap</span> <span class="symbol">&lt;C-s&gt;</span> :<span class="keyword">w</span><span class="symbol">&lt;CR&gt;</span></span><br><span class="line"><span class="keyword">nnoremap</span> <span class="symbol">&lt;F5&gt;</span> :<span class="keyword">w</span><span class="symbol">&lt;CR&gt;</span>:!g++ -DDEBUG % -<span class="keyword">o</span> ./out/%&lt; -g -std=<span class="keyword">c</span>++<span class="number">11</span> -Wall &amp;&amp; time ./out/%&lt;<span class="symbol">&lt;CR&gt;</span></span><br><span class="line">fun Init()</span><br><span class="line">    <span class="keyword">rightbelow</span> <span class="keyword">vsplit</span> test/main.out</span><br><span class="line">    <span class="keyword">split</span> test/main.in</span><br><span class="line">    <span class="keyword">wincmd</span> h</span><br><span class="line">endfun</span><br><span class="line"><span class="keyword">autocmd</span> VimEnter *.cpp <span class="keyword">call</span> Init()</span><br><span class="line"><span class="keyword">autocmd</span> BufNewFile *.cpp <span class="number">0</span>r head.cpp</span><br><span class="line"></span><br><span class="line"><span class="comment">&quot; rnu: relativenumber, hls: hlsearch, cin: cindent</span></span><br><span class="line"><span class="comment">&quot; et: expandtab, ts: tabstop, sw: shiftwidth so: scrolloff</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法竞赛</category>
        <category>模板</category>
      </categories>
  </entry>
  <entry>
    <title>取模整数类</title>
    <url>/2024/10/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/%E6%A8%A1%E6%9D%BF/ModInt/</url>
    <content><![CDATA[<p>在做数学题目时, 结果对一个质数取模是很常见的情况,
如果把模意义下的四则运算封装起来可以使得式子更简洁.</p>
<span id="more"></span>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">ModInt</span> &#123;</span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">pow_mod</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (b &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (b &amp; <span class="number">1</span>) ans = (ll)ans * a % MOD;</span><br><span class="line">            a = (ll)a * a % MOD, b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">inv</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">pow_mod</span>(x, MOD - <span class="number">2</span>); &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="type">static</span> <span class="keyword">constexpr</span> <span class="type">int</span> MOD = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    <span class="built_in">ModInt</span>(<span class="type">int</span> v = <span class="number">0</span>) : <span class="built_in">val</span>((v % MOD + MOD) % MOD) &#123;&#125;</span><br><span class="line">    ModInt <span class="keyword">operator</span>+(<span class="type">const</span> ModInt&amp; mi) <span class="type">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">ModInt</span>((val + mi.val) % MOD);</span><br><span class="line">    &#125;</span><br><span class="line">    ModInt&amp; <span class="keyword">operator</span>+=(<span class="type">const</span> ModInt&amp; mi) &#123;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span> = *<span class="keyword">this</span> + mi;</span><br><span class="line">    &#125;</span><br><span class="line">    ModInt <span class="keyword">operator</span>-(<span class="type">const</span> ModInt&amp; mi) <span class="type">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">ModInt</span>((val - mi.val + MOD) % MOD);</span><br><span class="line">    &#125;</span><br><span class="line">    ModInt&amp; <span class="keyword">operator</span>-=(<span class="type">const</span> ModInt&amp; mi) &#123;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span> = *<span class="keyword">this</span> - mi;</span><br><span class="line">    &#125;</span><br><span class="line">    ModInt <span class="keyword">operator</span>*(<span class="type">const</span> ModInt&amp; mi) <span class="type">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">ModInt</span>((ll)val * mi.val % MOD);</span><br><span class="line">    &#125;</span><br><span class="line">    ModInt&amp; <span class="keyword">operator</span>*=(<span class="type">const</span> ModInt&amp; mi) &#123;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span> = *<span class="keyword">this</span> * mi;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">friend</span> istream&amp; <span class="keyword">operator</span>&gt;&gt;(istream&amp; in, ModInt&amp; mi) &#123;</span><br><span class="line">        <span class="keyword">return</span> (in &gt;&gt; mi.val, mi.val = (mi.val % MOD + MOD) % MOD, in);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">friend</span> ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; out, <span class="type">const</span> ModInt&amp; mi) &#123;</span><br><span class="line">        <span class="keyword">return</span> out &lt;&lt; mi.val;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// MOD must be a prime number</span></span><br><span class="line">    ModInt <span class="keyword">operator</span>/(<span class="type">const</span> ModInt&amp; mi) <span class="type">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">ModInt</span>((ll)val * <span class="built_in">inv</span>(mi.val) % MOD);</span><br><span class="line">    &#125;</span><br><span class="line">    ModInt&amp; <span class="keyword">operator</span>/=(<span class="type">const</span> ModInt&amp; mi) &#123;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span> = *<span class="keyword">this</span> / mi;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法竞赛</category>
        <category>模板</category>
      </categories>
      <tags>
        <tag>cpp</tag>
      </tags>
  </entry>
  <entry>
    <title>树状数组模板</title>
    <url>/2024/11/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/%E6%A8%A1%E6%9D%BF/FenwickTree/</url>
    <content><![CDATA[<p>简单的树状数组模板.</p>
<span id="more"></span>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">BIT</span> &#123;</span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> n_;</span><br><span class="line">    vector&lt;ll&gt; c_;</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">lowbit</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123; <span class="keyword">return</span> x &amp; -x; &#125;</span><br><span class="line">    <span class="function">ll <span class="title">pre</span><span class="params">(<span class="type">int</span> pos)</span> </span>&#123;</span><br><span class="line">        ll ret = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (; pos &gt; <span class="number">0</span>; pos -= <span class="built_in">lowbit</span>(pos)) ret += c_[pos];</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// please ensure that vec is 1-indexed</span></span><br><span class="line">    <span class="built_in">BIT</span>(<span class="type">const</span> vector&lt;<span class="type">int</span>&gt;&amp; vec) &#123;</span><br><span class="line">        n_ = vec.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        c_.<span class="built_in">resize</span>(n_ + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n_; i++) <span class="built_in">add</span>(i, vec[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> pos, <span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (; pos &lt;= n_; pos += <span class="built_in">lowbit</span>(pos)) c_[pos] += x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">ll <span class="title">query</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">pre</span>(r - <span class="number">1</span>) - <span class="built_in">pre</span>(l - <span class="number">1</span>); &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法竞赛</category>
        <category>模板</category>
      </categories>
      <tags>
        <tag>cpp</tag>
      </tags>
  </entry>
  <entry>
    <title>UVA1069 题解</title>
    <url>/2024/11/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/%E9%A2%98%E8%A7%A3/AOAPC-Training-Guide/E3-2-1/</url>
    <content><![CDATA[<p><a
href="https://onlinejudge.org/external/10/1069.pdf">英文题面</a></p>
<h2 id="题意">题意</h2>
<p>给出一个多项式，判断这个多项式是否恒取整数值。</p>
<span id="more"></span>
<h2 id="思路">思路</h2>
<p>本题难点实际上在字符串处理，我自认为这部分代码写的相对简单。</p>
<p>在开始之前，我们可以照着快读来完成整数的读入，不过这里对
<code>-n</code> 一类做了特判。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 从+-^/开始读一个数字</span></span><br><span class="line"><span class="function">ll <span class="title">read</span><span class="params">(<span class="type">int</span>&amp; cur)</span> </span>&#123;</span><br><span class="line">    ll x = <span class="number">0</span>, f = (s[cur++] == <span class="string">&#x27;-&#x27;</span> ? <span class="number">-1</span> : <span class="number">+1</span>);</span><br><span class="line">    <span class="type">char</span> ch = s[cur++];</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch)) x = x * <span class="number">10</span> + (ch - <span class="string">&#x27;0&#x27;</span>), ch = s[cur++];</span><br><span class="line">    <span class="keyword">return</span> (x == <span class="number">0</span> ? f : x * f);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>理想状态下我们希望读取的每一项都是 <code>Cn^E</code>
的形式，对于不属于这一形式的有一下几种可能。</p>
<ul>
<li><span class="math inline">\(C\)</span>
为正的时候，前面可能没有加号，这只会出现在字符串的第一项，所以只要第一项非负我们就插入一个加号</li>
<li><span class="math inline">\(C = \pm 1\)</span>
的时候，数字部分会被省略，这个在 <code>read()</code>
函数中加了特判。</li>
<li><span class="math inline">\(E = 0\)</span> 的时候，这时
<code>n^E</code> 都不存在了，那么读取完 <code>C</code> 就可以判断。</li>
<li><span class="math inline">\(E = 1\)</span> 的时候，这时
<code>^E</code> 不存在，那么就是存在 <code>n</code> 不存在
<code>^</code>。</li>
</ul>
<p>具体实现如下，思路跟着 <code>read()</code> 读完一次之后
<code>cur</code> 的位置往下写就可以了。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">parse</span><span class="params">(<span class="type">const</span> string&amp; s)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> cur = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 处理多项式部分</span></span><br><span class="line">    <span class="keyword">while</span> (cur &lt; (<span class="type">int</span>)s.<span class="built_in">size</span>() &amp;&amp; s[cur] != <span class="string">&#x27;)&#x27;</span>) &#123;</span><br><span class="line">        <span class="type">int</span> C = <span class="number">0</span>;</span><br><span class="line">        C = <span class="built_in">read</span>(cur);</span><br><span class="line">        <span class="keyword">if</span> (s[cur - <span class="number">1</span>] != <span class="string">&#x27;n&#x27;</span>) &#123;</span><br><span class="line">            P.<span class="built_in">push_back</span>(&#123;C, <span class="number">0</span>&#125;);</span><br><span class="line">            cur--;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">int</span> E = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (s[cur] == <span class="string">&#x27;^&#x27;</span>) &#123;</span><br><span class="line">                E = <span class="built_in">read</span>(cur);</span><br><span class="line">                cur--;</span><br><span class="line">            &#125;</span><br><span class="line">            P.<span class="built_in">push_back</span>(&#123;C, E&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 读取除数</span></span><br><span class="line">    cur++;</span><br><span class="line">    d = <span class="built_in">read</span>(cur);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="代码">代码</h2>
<p>我的实现是随机代入一些数字，确实可以过。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> all(a) a.begin(), a.end()</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll = <span class="type">long</span> <span class="type">long</span>;  <span class="comment">// 2.15e9, 9.22e18</span></span><br><span class="line"><span class="keyword">using</span> pii = pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> d;</span><br><span class="line">string s;</span><br><span class="line">vector&lt;pii&gt; P;  <span class="comment">// first: 系数, second: 次数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 从+-^/开始读一个数字</span></span><br><span class="line"><span class="function">ll <span class="title">read</span><span class="params">(<span class="type">int</span>&amp; cur)</span> </span>&#123;</span><br><span class="line">    ll x = <span class="number">0</span>, f = (s[cur++] == <span class="string">&#x27;-&#x27;</span> ? <span class="number">-1</span> : <span class="number">+1</span>);</span><br><span class="line">    <span class="type">char</span> ch = s[cur++];</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch)) x = x * <span class="number">10</span> + (ch - <span class="string">&#x27;0&#x27;</span>), ch = s[cur++];</span><br><span class="line">    <span class="keyword">return</span> (x == <span class="number">0</span> ? f : x * f);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">parse</span><span class="params">(<span class="type">const</span> string&amp; s)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> cur = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 处理多项式部分</span></span><br><span class="line">    <span class="keyword">while</span> (cur &lt; (<span class="type">int</span>)s.<span class="built_in">size</span>() &amp;&amp; s[cur] != <span class="string">&#x27;)&#x27;</span>) &#123;</span><br><span class="line">        <span class="type">int</span> C = <span class="number">0</span>;</span><br><span class="line">        C = <span class="built_in">read</span>(cur);</span><br><span class="line">        <span class="keyword">if</span> (s[cur - <span class="number">1</span>] != <span class="string">&#x27;n&#x27;</span>) &#123;</span><br><span class="line">            P.<span class="built_in">push_back</span>(&#123;C, <span class="number">0</span>&#125;);</span><br><span class="line">            cur--;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">int</span> E = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (s[cur] == <span class="string">&#x27;^&#x27;</span>) &#123;</span><br><span class="line">                E = <span class="built_in">read</span>(cur);</span><br><span class="line">                cur--;</span><br><span class="line">            &#125;</span><br><span class="line">            P.<span class="built_in">push_back</span>(&#123;C, E&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 读取除数</span></span><br><span class="line">    cur++;</span><br><span class="line">    d = <span class="built_in">read</span>(cur);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">pow_mod</span><span class="params">(ll a, ll b, ll MOD)</span> </span>&#123;</span><br><span class="line">    a %= MOD;</span><br><span class="line">    ll ans = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (b &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (b &amp; <span class="number">1</span>) ans = ans * a % MOD;</span><br><span class="line">        a = a * a % MOD;</span><br><span class="line">        b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">1e5</span>;</span><br><span class="line"><span class="function">mt19937_64 <span class="title">rng</span><span class="params">(random_device&#123;&#125;())</span></span>;</span><br><span class="line"><span class="function">uniform_int_distribution&lt;<span class="type">int</span>&gt; <span class="title">INT</span><span class="params">(<span class="number">0</span>, INF)</span></span>;</span><br><span class="line"><span class="comment">// 对多项式进行cnt轮随机测试</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(<span class="type">int</span> cnt)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; cnt; i++) &#123;</span><br><span class="line">        <span class="type">int</span> x = <span class="built_in">INT</span>(rng), ok = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> pii&amp; p : P) ok = (ok + p.first * <span class="built_in">pow_mod</span>(x, p.second, d)) % d;</span><br><span class="line">        <span class="keyword">if</span> (ok != <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>)-&gt;ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    <span class="type">int</span> kase = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (cin &gt;&gt; s &amp;&amp; s != <span class="string">&quot;.&quot;</span>) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Case &quot;</span> &lt;&lt; kase++ &lt;&lt; <span class="string">&quot;: &quot;</span>;</span><br><span class="line">        <span class="keyword">if</span> (s[<span class="number">1</span>] != <span class="string">&#x27;-&#x27;</span>) s.<span class="built_in">insert</span>(s.<span class="built_in">begin</span>() + <span class="number">1</span>, <span class="string">&#x27;+&#x27;</span>);</span><br><span class="line">        P.<span class="built_in">clear</span>();</span><br><span class="line">        <span class="built_in">parse</span>(s);</span><br><span class="line">        cout &lt;&lt; (<span class="built_in">check</span>(<span class="number">2333</span>) ? <span class="string">&quot;Always &quot;</span> : <span class="string">&quot;Not always &quot;</span>) &lt;&lt; <span class="string">&quot;an integer\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法竞赛</category>
        <category>题解</category>
      </categories>
      <tags>
        <tag>cpp</tag>
        <tag>AOAPC-Training-Guide</tag>
      </tags>
  </entry>
  <entry>
    <title>信导期中考题解</title>
    <url>/2024/11/%E5%A4%A7%E5%AD%A6/2024Fall-SI100B-midterm/</url>
    <content><![CDATA[<h2 id="考试环境">考试环境</h2>
<ul>
<li>操作系统: Windows10;</li>
<li>终端: <code>cmd</code>, 古董 <code>powershell</code>;</li>
<li>编辑器: <code>vscode</code> (包含插件 <code>pylance</code>,
<code>python debugger</code>, <code>pylint</code>), <code>vim</code>
(版本 <span class="math inline">\(9.1\)</span>), <code>gvim</code>;</li>
<li>IDE: <code>pycharm</code>;</li>
<li>外设: 键盘还可以, 鼠标手感稀烂. (有的机房可能键盘也烂)</li>
</ul>
<span id="more"></span>
<h2 id="考试题目">考试题目</h2>
<h3 id="第一场">第一场</h3>
<h4 id="a1-warm-up-20pts">A1 Warm Up (20pts)</h4>
<p>题意: 输入 <span class="math inline">\(x\)</span>, <span
class="math inline">\(n\)</span>, 输出 <span class="math inline">\(x^n +
1\)</span>.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x = <span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line">n = <span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(x ** n + <span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<h4 id="b1-median-25pts">B1 Median (25pts)</h4>
<p>题意: 输入数列, 输出中位数.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = <span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split()))</span><br><span class="line">a = <span class="built_in">sorted</span>(a)</span><br><span class="line">n = <span class="built_in">len</span>(a)</span><br><span class="line"></span><br><span class="line">ans = <span class="number">0</span></span><br><span class="line"><span class="keyword">if</span> n &amp; <span class="number">1</span>:</span><br><span class="line">    ans = a[n // <span class="number">2</span>]</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    ans = (a[n // <span class="number">2</span> - <span class="number">1</span>] + a[n // <span class="number">2</span>]) / <span class="number">2</span></span><br><span class="line"><span class="built_in">print</span>(ans)</span><br></pre></td></tr></table></figure>
<h4 id="c1-string-special-flip-25pts">C1 String Special Flip
(25pts)</h4>
<p>题意: 输入字符串, 偶数下标转大写, 奇数下标转小写. 最后逆序输出.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">s = <span class="built_in">input</span>()</span><br><span class="line">t = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(s)):</span><br><span class="line">    <span class="keyword">if</span> i &amp; <span class="number">1</span>:</span><br><span class="line">        t.append(s[i].lower())</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        t.append(s[i].upper())</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;&quot;</span>.join(t)[::-<span class="number">1</span>])</span><br></pre></td></tr></table></figure>
<h4 id="d1-a-bakeshop-30pts">D1 A Bakeshop (30pts)</h4>
<p>题意: 实现一个模拟面包房工作的类, 完成其中的三个函数.</p>
<ul>
<li><code>__init__</code> 函数的调用样例为
<code>bakery1 = BakeShop(shopName: str, shopTelephone: str)</code>;</li>
<li><code>__str__</code> 函数的输出格式为
<code>shopName tel:shopTelephone</code>;</li>
<li><code>stock</code> 函数传入 <code>list[str]</code>,
统计其中每个元素出现的次数, 调用样例
<code>bakery1.stock(['A', 'A', 'A'])</code>.</li>
</ul>
<p>本题其实有三个文件, 也许需要一定时间来理解
(事实上注意力只需要放在一个文件就行, 只是运行程序的时候入口不在这里)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">BakeShop</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name, telephone</span>):</span><br><span class="line">        <span class="variable language_">self</span>.name = name</span><br><span class="line">        <span class="variable language_">self</span>.telephone = telephone</span><br><span class="line">        <span class="variable language_">self</span>.val = &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__str__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">f&quot;<span class="subst">&#123;self.name&#125;</span> tel:<span class="subst">&#123;self.telephone&#125;</span>&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">stock</span>(<span class="params">self, goodslist</span>):</span><br><span class="line">        ans = []</span><br><span class="line">        <span class="keyword">for</span> goods <span class="keyword">in</span> goodslist:</span><br><span class="line">            <span class="keyword">if</span> goods <span class="keyword">in</span> <span class="variable language_">self</span>.val.keys():</span><br><span class="line">                <span class="variable language_">self</span>.val[goods] += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="variable language_">self</span>.val[goods] = <span class="number">1</span></span><br><span class="line">            ans.append(<span class="variable language_">self</span>.val[goods])</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
<h3 id="第二场">第二场</h3>
<p>本人没有参加第二场考试, 实现代码参考习题课课件.</p>
<h4 id="a2-heat-up-20pts">A2 Heat Up (20pts)</h4>
<p>题意: 输入 <span class="math inline">\(x\)</span>, 输出 <span
class="math inline">\(1 + 2 + \cdots + x\)</span>;</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x = <span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(x * (x + <span class="number">1</span>) // <span class="number">2</span>)</span><br></pre></td></tr></table></figure>
<h4 id="b2-the-kth-largest-element-25pts">B2 The kth Largest Element
(25pts)</h4>
<p>题意: 输入数列, 输出第 <span class="math inline">\(k\)</span>
大数;</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = <span class="built_in">map</span>(<span class="built_in">int</span>, intput().split())</span><br><span class="line">a = <span class="built_in">sorted</span>(a, reverse = <span class="literal">True</span>)</span><br><span class="line">k = <span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(a[k - <span class="number">1</span>])</span><br></pre></td></tr></table></figure>
<h4 id="c2-string-compression-25pts">C2 String Compression (25pts)</h4>
<p>题意: 输入只包含小写字母的字符串, 把其中连续部分压缩;
(<code>aaa</code> -&gt; <code>3a</code>)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">s = <span class="built_in">input</span>()</span><br><span class="line"><span class="comment"># 下面三行都是为了处理边界情况</span></span><br><span class="line"><span class="comment"># 1: 最后一个字母处理完不会更新 ans, 所以需要在末尾加上一个非小写字母</span></span><br><span class="line"><span class="comment"># 2: 第一个字母前面没有字母, 考虑使用一个非小写字母代替</span></span><br><span class="line"><span class="comment"># 3: 处理第一个字母为了不让 pre 被加入答案, 把 cnt 设置为 -1 与后面 &gt;= 1 的情况区分开</span></span><br><span class="line">s += <span class="string">&quot;-&quot;</span></span><br><span class="line">pre = <span class="string">&quot;=&quot;</span></span><br><span class="line">cnt = -<span class="number">1</span></span><br><span class="line"></span><br><span class="line">ans = []</span><br><span class="line"><span class="keyword">for</span> ch <span class="keyword">in</span> s:</span><br><span class="line">    <span class="keyword">if</span> ch == pre:</span><br><span class="line">        cnt += <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">if</span> cnt == <span class="number">1</span>:</span><br><span class="line">            ans.append(pre)</span><br><span class="line">        <span class="keyword">elif</span> cnt &gt; <span class="number">1</span>:</span><br><span class="line">            ans.append(<span class="string">f&quot;<span class="subst">&#123;cnt&#125;</span><span class="subst">&#123;pre&#125;</span>&quot;</span>)</span><br><span class="line">        cnt = <span class="number">1</span></span><br><span class="line">        pre = ch</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;&quot;</span>.join(ans))</span><br></pre></td></tr></table></figure>
<h4 id="d2-a-bakeshop-ii-30pts">D2: A Bakeshop II (30pts)</h4>
<p>题意: 实现一个模拟面包房工作的类, 完成其中的三个函数.</p>
<ul>
<li><code>__init__</code> 函数的调用样例为
<code>bakery1 = BakeShop(shopName: str, opening_hours: str, priceTable: dict[str, int])</code>;</li>
<li><code>__str__</code> 函数的输出格式为
<code>shopName (opening_hours)</code>;</li>
<li><code>sale</code> 函数传入一个 <code>list[str]</code>, 统计其中在
<code>priceTable</code> 里的部分并统计总价格, 调用样例
<code>bakery1.sale(['A', 'B', 'B', 'B', 'A'])</code>.</li>
</ul>
<p>本题同样有三个文件.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">BakeShop</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name, opening_hours, priceTable</span>):</span><br><span class="line">        <span class="variable language_">self</span>.name = name</span><br><span class="line">        <span class="variable language_">self</span>.opening_hours = opening_hours</span><br><span class="line">        <span class="variable language_">self</span>.val = priceTable</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__str__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">f&quot;<span class="subst">&#123;self.name&#125;</span> (<span class="subst">&#123;self.opening_hours&#125;</span>)&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">sale</span>(<span class="params">self, goodslist</span>):</span><br><span class="line">        ret = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> goods <span class="keyword">in</span> goodslist:</span><br><span class="line">            <span class="keyword">if</span> goods <span class="keyword">in</span> <span class="variable language_">self</span>.val.keys():</span><br><span class="line">                ret += <span class="variable language_">self</span>.val[goods]</span><br><span class="line">        <span class="keyword">return</span> ret</span><br></pre></td></tr></table></figure>
<h2 id="考试总结">考试总结</h2>
<p>机房环境比想象中好, 不过还是建议装个新版本 <code>pwsh</code>.</p>
<p>考试时间 <span class="math inline">\(45\)</span> 分钟, 我花了快 <span
class="math inline">\(30\)</span> 分钟, 时间应该不是特别紧张 (?).</p>
<p>其实我觉得这场考试不好出, 面对的学生应该是刚接触编程两个月的人,
时间相当短 (为了两节课考完两批人我还是可以理解的),
而且两场考试难度应当差不多. 题目自然不能出的太难,
但是又需要尽量全面的涉及学习过的知识.</p>
<p>这样看下来感觉题目还可以, 考察了简单的输入与输出, 数组切片
(逆序输出), 常用函数 len(), sorted(), 字符串相关的大小写转换,
类初始化与魔术方法.</p>
<p><del>看上去第二场前三题比第一场难欸</del></p>
]]></content>
      <categories>
        <category>大学</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>ABC383F 题解</title>
    <url>/2024/12/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/%E9%A2%98%E8%A7%A3/AtCoder/ABC383F/</url>
    <content><![CDATA[<p><a
href="https://atcoder.jp/contests/abc383/tasks/abc383_f">英文题面</a></p>
<h2 id="题意">题意</h2>
<p>已知 <span class="math inline">\(N\)</span> 件商品，第 <span
class="math inline">\(i\)</span> 件商品的价格为 <span
class="math inline">\(P_i\)</span>，价值为 <span
class="math inline">\(U_i\)</span>，颜色为 <span
class="math inline">\(C_i\)</span>；和一个给定的常数 <span
class="math inline">\(K\)</span>。</p>
<p>你希望购买总价格不超过 <span class="math inline">\(X\)</span>
单位的商品（每件可以不买或买一个），使得 <span class="math inline">\(S +
T \times K\)</span> 最大。其中 <span class="math inline">\(S\)</span>
是选择的商品总价值，<span class="math inline">\(T\)</span>
是这些商品的不同颜色数。</p>
<p>数据范围：</p>
<ul>
<li><span class="math inline">\(1 \le N, C_i \le 500\)</span>；</li>
<li><span class="math inline">\(1 \le K, P_i, U_i \le
10^9\)</span>；</li>
<li><span class="math inline">\(1 \le X \le 5 \times
10^4\)</span>。</li>
</ul>
<span id="more"></span>
<h2 id="思路">思路</h2>
<p>不难想到这是背包问题的变式，但是目标值有两个变量。我们可以先看看每次选择一个新商品对目标值的影响：
<span class="math display">\[\Delta F_i = U_i + \begin{cases}K &amp;
\text{没有选择过 } C_i \\ 0 &amp; \text{已经选择过 } C_i
\end{cases}\]</span>
可以发现第一项就是背包板子，第二项启示我们可以根据颜色来分组决策。那么先根据颜色给商品排个序，依旧定义
<span class="math inline">\(f(i, j)\)</span> 为考虑前 <span
class="math inline">\(i\)</span> 个商品用去价值 <span
class="math inline">\(j\)</span> 所得的最大目标值。</p>
<p>如果已经选择过 <span class="math inline">\(C_i\)</span>,
转移方程就是简单的 <span class="math display">\[f(i, j) \leftarrow f(i -
1, j - P_i) + U_i\]</span></p>
<p>如果没有选择过 <span class="math inline">\(C_i\)</span>,
那么这一整组, <span class="math inline">\(i\)</span>
之前的商品等于被跳过了，记录上一组最后位置是 <span
class="math inline">\(p\)</span>，转移方程变为了 <span
class="math display">\[f(i, j) \leftarrow f(p, j - P_i) + U_i +
K\]</span></p>
<p>然后考虑用滚动数组优化，在遇上新一组商品的时候令
<code>vector&lt;int&gt;g = f</code> 保留上一组最后位置的状态，</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = X; j &gt;= P[i]; j--) &#123;</span><br><span class="line">    f[j] = <span class="built_in">max</span>(f[j], f[j - P[i]] + U[i]);</span><br><span class="line">    f[j] = <span class="built_in">max</span>(f[j], g[j - P[i]] + U[i] + K);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后考虑一下边界条件，发现全部初始化为 <span
class="math inline">\(0\)</span> 就可以了。</p>
<h2 id="代码">代码</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> all(a) a.begin(), a.end()</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll = <span class="type">long</span> <span class="type">long</span>;  <span class="comment">// 2.15e9, 9.22e18</span></span><br><span class="line"><span class="keyword">using</span> pii = pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Item</span> &#123;</span><br><span class="line">    <span class="type">int</span> p, u, c;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> Item&amp; rhs) <span class="type">const</span> &#123; <span class="keyword">return</span> c &lt; rhs.c; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, x, k;</span><br><span class="line">vector&lt;ll&gt; f;</span><br><span class="line">vector&lt;Item&gt; a;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>)-&gt;<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; x &gt;&gt; k;</span><br><span class="line">    a.<span class="built_in">resize</span>(n);</span><br><span class="line">    f.<span class="built_in">resize</span>(x + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) cin &gt;&gt; a[i].p &gt;&gt; a[i].u &gt;&gt; a[i].c;</span><br><span class="line">    <span class="built_in">sort</span>(<span class="built_in">all</span>(a));</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> prec = <span class="number">0</span>;</span><br><span class="line">    vector&lt;ll&gt; g = f;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (a[i].c != prec) &#123;</span><br><span class="line">            prec = a[i].c;</span><br><span class="line">            g = f;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = x; j &gt;= a[i].p; j--) &#123;</span><br><span class="line">            f[j] = <span class="built_in">max</span>(f[j], f[j - a[i].p] + a[i].u);</span><br><span class="line">            f[j] = <span class="built_in">max</span>(f[j], g[j - a[i].p] + a[i].u + k);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; f[x] &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法竞赛</category>
        <category>题解</category>
      </categories>
      <tags>
        <tag>cpp</tag>
        <tag>AtCoder</tag>
      </tags>
  </entry>
</search>
